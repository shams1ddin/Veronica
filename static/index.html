<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Veronica AI</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <link href="css/starry-sky.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked@4.0.0/marked.min.js"></script>
    <style>
        :root {
    --primary-bg: #262624;
    --accent-color: #5759D9;
    --text-color: #B0B0B0;
    --border-color: #4A4A46;
    --hover-color: #3A3B44;
    --animation-timing: 0.5s;
    --close-btn-color: #FF0000;
    --send-btn-color: linear-gradient(135deg, #5759D9, #3A3B44);
    --send-btn-hover-color: #4F51B5;
    --error-bg: rgba(244, 67, 54, 0.9);
    --error-text: #ffffff;
}

body {
    margin: 0;
    padding: 0;
    font-family: 'Poppins', sans-serif;
    background: var(--primary-bg);
    color: var(--text-color);
    line-height: 1.6;
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    font-size: 16px;
}

.error-notification {
    position: fixed;
    top: -100px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--error-bg);
    color: var(--error-text);
    padding: 1rem 2rem;
    border-radius: 8px;
    z-index: 9999;
    transition: top 0.5s ease;
    font-size: 0.9rem;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    text-align: center;
}

.error-notification.show {
    top: 20px;
}

.notification {
    position: fixed;
    top: -100px;
    left: 50%;
    transform: translateX(-50%);
    background: #4CAF50;
    color: white;
    padding: 1rem 2rem;
    border-radius: 8px;
    z-index: 9999;
    transition: top 0.5s ease;
    font-size: 0.9rem;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    text-align: center;
}

.notification.show {
    top: 20px;
}

.app-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: 100vh;
    position: relative;
}

.sidebar {
    position: fixed;
    left: 0;
    top: 0;
    height: 100%;
    width: 260px;
    background: var(--primary-bg);
    border-right: 1px solid var(--border-color);
    transform: translateX(-100%);
    transition: transform var(--animation-timing) ease;
    z-index: 1000;
    display: flex;
    flex-direction: column;
}

.sidebar.open {
    transform: translateX(0);
}

.sidebar-header {
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.sidebar-title {
    font-size: 1.25rem;
    font-weight: 600;
}

.sidebar-actions {
    display: flex;
    gap: 0.5rem;
}

.sidebar-action-btn {
    background: transparent;
    border: 1px solid var(--border-color);
    color: var(--text-color);
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 10px;
    transition: color 0.3s ease, border-color 0.3s ease;
}

.sidebar-action-btn:hover {
    color: var(--accent-color);
    border-color: var(--accent-color);
}

.sidebar-action-btn#close-sidebar-btn:hover {
    color: var(--close-btn-color);
    border-color: var(--close-btn-color);
}

.chat-list {
    padding: 0.5rem;
    overflow-y: auto;
    flex: 1;
}

.chat-item {
    padding: 0.5rem;
    background: transparent;
    border: none;
    color: var(--text-color);
    text-align: left;
    width: 100%;
    cursor: pointer;
    transition: background 0.3s ease, color 0.3s ease;
}

.chat-item:hover {
    background: var(--hover-color);
    color: var(--accent-color);
}

.user-info {
    padding: 1rem;
    border-top: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    transition: background 0.3s ease;
}

.user-info:hover {
    background: var(--hover-color);
}

.user-info svg {
    width: 20px;
    height: 20px;
}

.user-info .user-icon {
    border: 1px solid var(--border-color);
    border-radius: 50%;
    padding: 0.2rem;
}

.user-name {
    flex: 1;
    font-size: 1rem;
    color: var(--text-color);
}

.settings-btn {
    background: transparent;
    border: 1px solid var(--border-color);
    color: var(--text-color);
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 10px;
    transition: color 0.3s ease, border-color 0.3s ease;
}

.settings-btn:hover {
    color: var(--accent-color);
    border-color: var(--accent-color);
}

.header {
    padding: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 10;
    height: 60px;
    box-sizing: border-box;
}

.logo {
    font-size: 1.5rem;
    font-weight: 600;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}

.header-actions {
    display: flex;
    gap: 0.5rem;
}

.action-btn {
    background: transparent;
    border: 1px solid var(--border-color);
    color: var(--text-color);
    padding: 0.5rem;
    cursor: pointer;
    border-radius: 0.375rem;
    transition: color 0.3s ease, border-color 0.3s ease;
}

.action-btn:hover {
    color: var(--accent-color);
    border-color: var(--accent-color);
}

.scroll-container {
    width: 100%;
    overflow-y: auto;
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    box-sizing: border-box;
    z-index: 2;
}

.scroll-container::-webkit-scrollbar {
    width: 8px;
}

.scroll-container::-webkit-scrollbar-track {
    background: var(--primary-bg);
    border-radius: 10px;
}

.scroll-container::-webkit-scrollbar-thumb {
    background: var(--accent-color);
    border-radius: 10px;
    border: 2px solid var(--primary-bg);
}

.chat-messages {
    width: 80%;
    max-width: 800px;
    min-width: 300px;
    margin: 0 auto;
    padding: 2rem;
    padding-top: 80px;
    padding-bottom: 150px;
    display: flex;
    flex-direction: column;
    scroll-behavior: smooth;
    box-sizing: border-box;
    min-height: 100%;
}

.message {
    display: flex;
    padding: 1rem;
    gap: 1rem;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity var(--animation-timing) ease-out, transform var(--animation-timing) ease-out;
    border-radius: 8px;
    max-width: 700px;
    background: none;
    position: relative;
    margin-bottom: 45px;
}

.message.visible {
    opacity: 1;
    transform: translateY(0);
}

.generation-time {
    font-size: 0.85rem;
    color: var(--text-color);
    opacity: 0.8;
    text-align: center;
    margin-top: 8px;
    font-style: italic;
}

.user-message-actions {
    display: flex;
    gap: 0.5rem;
    opacity: 0;
    transition: opacity 0.2s ease;
    margin-top: 0.5rem;
    justify-content: flex-end;
    position: absolute;
    bottom: -45px;
    right: 0;
    background: transparent;
    padding: 5px;
    border-radius: 8px;
}

.assistant-message-actions {
    display: flex;
    gap: 0.5rem;
    opacity: 0;
    transition: opacity 0.2s ease;
    margin-top: 0.5rem;
    justify-content: flex-end;
    position: absolute;
    bottom: -15px;
    background: transparent;
    padding: 5px;
    border-radius: 8px;
}

.message:hover .user-message-actions,
.message:hover .assistant-message-actions {
    opacity: 1;
}

.user-message-action-btn,
.assistant-message-action-btn {
    position: relative;
    background: transparent;
    border: 1px solid var(--border-color);
    color: var(--text-color);
    padding: 0.5rem;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}

.user-message-action-btn:hover,
.assistant-message-action-btn:hover {
    border-color: var(--accent-color);
    color: var(--accent-color);
}

.user-message-action-btn svg,
.assistant-message-action-btn svg {
    width: 12px;
    height: 12px;
}

.user-message-action-btn::after,
.assistant-message-action-btn::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: calc(100% + 5px);
    left: 50%;
    transform: translateX(-50%);
    padding: 0.5rem;
    background: var(--hover-color);
    border-radius: 4px;
    font-size: 0.8rem;
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s ease;
    pointer-events: none;
}

.user-message-action-btn:hover::after,
.assistant-message-action-btn:hover::after {
    opacity: 1;
    visibility: visible;
    bottom: calc(100% + 5px);
}

.assistant-message-action-btn[data-tooltip="Нравится"].active {
    color: #4CAF50;
    background-color: rgba(76, 175, 80, 0.2);
    border-color: #4CAF50;
}

.assistant-message-action-btn[data-tooltip="Требует доработки"].active {
    color: #F44336;
    background-color: rgba(244, 67, 54, 0.2);
    border-color: #F44336;
}

.message.editing .message-content {
    border: 1px solid var(--accent-color);
    padding: 0.5rem;
    border-radius: 8px;
    outline: none;
    min-height: 100px;
    min-width: 600px;
    caret-position: end;
}

.message.editing .message-actions {
    display: none;
}

.message-edit-actions {
    display: none;
    gap: 0.5rem;
    margin-top: 0.5rem;
    justify-content: flex-end;
    position: absolute;
    right: 0;
    bottom: -50px;
}

.message.editing .message-edit-actions {
    display: flex;
}

.message.editing .message-edit-actions button {
    background: transparent;
    border: 1px solid var(--border-color);
    color: var(--text-color);
    padding: 0.5rem 1.5rem;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.message.editing .message-edit-actions button:hover {
    border-color: var(--accent-color);
    color: var(--accent-color);
}

.message.user {
    margin-left: auto;
    max-width: 700px;
}

.message.user-text {
    background: linear-gradient(135deg, #5759D9, #3A3B44);
    padding: 0.8rem 1.2rem;
    border-radius: 18px 18px 4px 18px;
}

.message.user-img {
    background: none;
    padding: 0.5rem;
    border-radius: 12px;
}

.message.user-files {
    background: rgba(87, 89, 217, 0.05);
    padding: 0.1rem;
    border-radius: 8px;
}

.message.assistant {
    margin-right: auto;
    max-width: 700px;
    display: block;
}

.message-content {
    font-size: 1rem;
    line-height: 1.5;
    white-space: pre-wrap;
}

.message-content h1,
.message-content h2,
.message-content h3,
.message-content h4,
.message-content h5,
.message-content h6 {
    margin-top: 0.5rem;
    margin-bottom: 0.25rem;
    line-height: 1.3;
    color: var(--accent-color);
    font-weight: 600;
}

.message-content h1 {
    font-size: 1.5rem;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 0.2rem;
}

.message-content h2 {
    font-size: 1.3rem;
}

.message-content h3 {
    font-size: 1.2rem;
}

.message-content p {
    margin-top: 0.25rem;
    margin-bottom: 0.25rem;
    color: var(--text-color);
}

.message-content a {
    color: var(--accent-color);
    text-decoration: none;
    transition: color 0.3s ease;
}

.message-content a:hover {
    color: var(--hover-color);
    text-decoration: underline;
}

.message-content code {
    background: var(--hover-color);
    color: #ffffff;
    padding: 0.2rem 0.4rem;
    border-radius: 4px;
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.9rem;
}

.message-content pre {
    background: var(--hover-color);
    padding: 1rem;
    border-radius: 8px;
    overflow-x: auto;
    margin: 0.5rem 0;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.message-content pre code {
    background: none;
    padding: 0;
}

.message-content blockquote {
    border-left: 4px solid var(--accent-color);
    padding-left: 1rem;
    margin: 0.5rem 0;
    color: var(--text-color);
    font-style: italic;
}

.message-content ul,
.message-content ol {
    margin-top: 0.25rem;
    margin-bottom: 0.25rem;
    padding-left: 1.5rem;
}

.message-content li {
    margin-bottom: 0.1rem;
}

.attachment-list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: 0.5rem;
}

.attachment-item {
    display: flex;
    align-items: center;
    background: var(--hover-color);
    border-radius: 10px;
    padding: 0.5rem;
    width: 200px;
    height: 45px;
    position: relative;
    overflow: hidden;
}

.attachment-item.image {
    padding: 0;
    overflow: hidden;
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: var(--hover-color);
}

.attachment-item img {
    object-fit: cover;
    border-radius: 10px;
    cursor: pointer;
}

.attachment-item.file {
    gap: 0.5rem;
    display: inline-flex;
    align-items: center;
    min-width: 150px;
    max-width: 550px;
    width: auto;
    cursor: pointer;
}

.attachment-content {
    display: flex;
    align-items: center;
    gap: 8px;
}

.file-info {
    max-width: 100%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.attachment-item.image img {
    width: 150px;
    height: auto;
    object-fit: contain;
    border-radius: 10px;
}
#preview-image {
    max-width: 45rem;
}

.attachment-icon {
    margin-top: 6px;
    width: 32px;
    height: 32px;
    fill: var(--accent-color);
    margin-right: 12px;
    padding: 6px;
    background: rgba(87, 89, 217, 0.1);
    border-radius: 8px;
}

.attachment-name {
    font-size: 1rem;
    color: var(--text-color);
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: flex;
    flex-direction: column;
}

.attachment-name::after {
    content: attr(data-type);
    font-size: 0.8rem;
    color: var(--text-color);
    opacity: 0.7;
}

.remove-attachment-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 20px;
    height: 20px;
    background: linear-gradient(135deg, rgba(87, 89, 217, 0.5), rgba(38, 38, 36, 0.8));
    border: none;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    transition: transform 0.2s ease, background 0.3s ease, box-shadow 0.3s ease;
    z-index: 10;
    opacity: 0;
    transform: scale(0.8);
    animation: appear 0.3s ease forwards;
}

@keyframes appear {
    to {
        opacity: 1;
        transform: scale(1);
    }
}

.remove-attachment-btn:hover {
    background: linear-gradient(135deg, rgba(255, 0, 0, 0.7), rgba(87, 89, 217, 0.8));
    transform: scale(1.1);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
}

.remove-attachment-btn:hover svg {
    transform: scale(1.2);
}

.remove-attachment-btn:active::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background: rgba(255, 0, 0, 0.3);
    border-radius: 50%;
    animation: ripple 0.5s ease-out;
}

@keyframes ripple {
    0% {
        transform: scale(1);
        opacity: 1;
    }
    100% {
        transform: scale(2.5);
        opacity: 0;
    }
}

.remove-attachment-btn svg {
    width: 12px;
    height: 12px;
    stroke: #FFFFFF;
    transition: transform 0.2s ease;
}

.message-attachment-list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: 0.5rem;
}

.message-attachment-item {
    display: flex;
    border-radius: 10px;
    padding: 0.5rem;
    width: 250px;
    height: 50px;
}

.message-attachment-item.image {
    position: relative;
    padding: 0;
    overflow: hidden;
    width: 30em;
    height: 300px;
}

.message-attachment-item.image .remove-attachment-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    background: linear-gradient(135deg, rgba(87, 89, 217, 0.5), rgba(38, 38, 36, 0.8));
    border-radius: 50%;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
}

.message-attachment-item.image .remove-attachment-btn svg {
    width: 10px;
    height: 9px;
    stroke: #FFFFFF;
}

.message-attachment-item.editing .remove-attachment-btn {
    display: flex;
}

.attachment-item .remove-attachment-btn {
    display: flex;
    align-items: center;
    justify-content: center;
}

.message-attachment-item.image .remove-attachment-btn:hover {
    background: linear-gradient(135deg, rgba(255, 0, 0, 0.7), rgba(87, 89, 217, 0.8));
}

.message-attachment-item img {
    width: auto;
    object-fit: cover;
    border-radius: 10px;
    cursor: pointer;
}

.message-attachment-item.file {
    gap: 0.5rem;
    cursor: pointer; 
}

.message-attachment-icon {
    width: 32px;
    height: 32px;
    fill: var(--accent-color);
    margin-right: 12px;
    padding: 6px;
    background: rgba(87, 89, 217, 0.1);
    border-radius: 8px;
}

.message-attachment-name {
    font-size: 1rem;
    color: var(--text-color);
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: flex;
    flex-direction: column;
    margin-top: 0.6rem;
}

.message-attachment-name::after {
    content: attr(data-type);
    font-size: 0.8rem;
    color: var(--text-color);
    opacity: 0.7;
}

.image-preview-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10000;
}

.image-preview-overlay.active {
    display: flex;
}

.image-preview-content {
    position: relative;
    max-width: 90%;
    max-height: 90%;
}

.image-preview-content img {
    border-radius: 10px;
}

.close-preview-btn {
    position: absolute;
    top: -40px;
    right: 0;
    background: transparent;
    border: none;
    color: #fff;
    cursor: pointer;
    padding: 0.5rem;
}

.close-preview-btn svg {
    width: 24px;
    height: 24px;
}

.processing-indicator {
    display: none;
    align-items: center;
    gap: 0.5rem;
    padding: 1rem;
    max-width: 700px;
    margin-right: auto;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity var(--animation-timing) ease-out, transform var(--animation-timing) ease-out;
}
.processing-indicator,
.thinking-indicator,
.loading-indicator {
    display: none; /* По умолчанию скрыты */
    align-items: center;
    gap: 0.5rem;
    padding: 1rem;
    max-width: 700px;
    margin-right: auto;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity var(--animation-timing) ease-out, transform var(--animation-timing) ease-out;
}
/* Увеличиваем специфичность и добавляем !important для видимости */
.processing-indicator.active,
.thinking-indicator.active,
.loading-indicator.active {
    display: flex !important;
    opacity: 1 !important;
    transform: translateY(0) !important;
}
.processing-indicator.active {
    display: flex;
    opacity: 1;
    transform: translateY(0);
}

.processing-dot {
    width: 8px;
    height: 8px;
    background: var(--accent-color);
    border-radius: 50%;
    animation: pulse 1.2s ease-in-out infinite;
}

.processing-dot:nth-child(2) {
    animation-delay: 0.2s;
}

.processing-dot:nth-child(3) {
    animation-delay: 0.4s;
}

/* Стили для индикатора DeepSearch */
.deepsearch-indicator {
    display: none;
    align-items: center;
    gap: 0.5rem;
    padding: 1rem;
    max-width: 700px;
    margin-right: auto;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity var(--animation-timing) ease-out, transform var(--animation-timing) ease-out;
}

.deepsearch-indicator.active {
    display: flex !important;
    opacity: 1 !important;
    transform: translateY(0) !important;
}

.deepsearch-spinner {
    width: 16px;
    height: 16px;
    border: 2px solid var(--text-color);
    border-top: 2px solid var(--accent-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.deepsearch-text {
    font-size: 0.9rem;
}

/* Стили для индикатора генерации изображений */
.image-gen-indicator {
    display: none;
    align-items: center;
    gap: 0.5rem;
    padding: 1rem;
    max-width: 700px;
    margin-right: auto;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity var(--animation-timing) ease-out, transform var(--animation-timing) ease-out;
}

.image-gen-indicator.active {
    display: flex !important;
    opacity: 1 !important;
    transform: translateY(0) !important;
}

.image-gen-spinner {
    width: 16px;
    height: 16px;
    border: 2px solid var(--text-color);
    border-top: 2px solid var(--accent-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.image-gen-text {
    font-size: 0.9rem;
}

@keyframes pulse {
    0%, 100% {
        transform: scale(1);
        opacity: 0.5;
    }
    50% {
        transform: scale(1.5);
        opacity: 1;
    }
}

.thinking-indicator {
    display: none;
    align-items: center;
    gap: 0.5rem;
    padding: 1rem;
    max-width: 700px;
    margin-right: auto;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity var(--animation-timing) ease-out, transform var(--animation-timing) ease-out;
}

.thinking-indicator.visible {
    display: flex;
    opacity: 1;
    transform: translateY(0);
}

.thinking-spinner {
    width: 16px;
    height: 16px;
    border: 2px solid var(--text-color);
    border-top: 2px solid var(--accent-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.thinking-time {
    font-size: 0.9rem;
}

@keyframes spin {
    0% {
        transform: rotate(0deg);
    }
    100% {
        transform: rotate(360deg);
    }
}

.loading-indicator {
    display: none;
    align-items: center;
    gap: 0.5rem;
    padding: 1rem;
    max-width: 700px;
    margin-right: auto;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity var(--animation-timing) ease-out, transform var(--animation-timing) ease-out;
}

.loading-indicator.active {
    display: flex;
    opacity: 1;
    transform: translateY(0);
}

.loading-spinner {
    width: 16px;
    height: 16px;
    border: 2px solid var(--text-color);
    border-top: 2px solid var(--accent-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.loading-text {
    font-size: 0.9rem;
}

.greeting {
    position: absolute;
    top: 35%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 2.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    opacity: 0;
    transition: opacity 0.8s ease-out, transform 0.8s ease-out;
}

.greeting.visible {
    opacity: 1;
    transform: translate(-50%, -50%);
}

.greeting.hidden {
    opacity: 0;
    transform: translate(-50%, -70%);
}

.greeting svg {
    width: 45px;
    height: 45px;
    fill: var(--accent-color);
    stroke: none;
}

.greeting-time {
    color: var(--text-color);
}

.greeting-user {
    color: var(--accent-color);
}

.chat-input-container {
    padding: 1.5rem;
    position: fixed;
    bottom: 0;
    width: 100%;
    z-index: 10;
    background: transparent;
}

.chat-input-wrapper {
    width: 80%;
    max-width: 700px;
    min-width: 300px;
    margin: 0 auto;
    background: #262624;
    border: 1px solid var(--border-color);
    border-radius: 20px;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    transition: border-color var(--animation-timing) ease;
}

.chat-input-wrapper:focus-within {
    border-color: var(--accent-color);
}

.chat-input-area {
    display: flex;
    align-items: center;
    padding-top: 0.75rem;
    padding-left: 0.5rem;
    padding-right: 0.5rem;
}

.chat-input {
    flex: 1;
    background: transparent;
    border: none;
    color: #fff;
    font-size: 1rem;
    resize: none;
    padding: 0;
    min-height: 24px;
    max-height: 200px;
    outline: none;
}

.chat-input::-webkit-scrollbar {
    width: 8px;
}

.chat-input::-webkit-scrollbar-track {
    background: var(--primary-bg);
    border-radius: 10px;
}

.chat-input::-webkit-scrollbar-thumb {
    background: var(--accent-color);
    border-radius: 10px;
    border: 2px solid var(--primary-bg);
}

.chat-input {
    scrollbar-width: thin;
    scrollbar-color: var(--accent-color) var(--primary-bg);
}

.chat-input::placeholder {
    color: var(--text-color);
}

.input-actions {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    justify-content: space-between;
    padding-top: 0.75rem;
}

.input-icons {
    display: flex;
    gap: 10px;
    align-items: center;
}

.input-icons button {
    background: transparent;
    border: 1px solid var(--border-color);
    color: #fff;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 0.5rem;
    border-radius: 10px;
    transition: color 0.3s ease, border-color 0.3s ease;
}

.input-icons button:hover {
    color: var(--accent-color);
    border-color: var(--accent-color);
}

.input-icons button.active {
    color: var(--accent-color);
    border-color: var(--accent-color);
}

.input-icons svg {
    width: 20px;
    height: 20px;
}

.think-btn,
.files-btn {
    font-family: 'Poppins', sans-serif;
    font-size: 0.9rem;
    padding: 0.5rem;
}

.input-right {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.custom-dropdown {
    position: relative;
    display: inline-block;
}

.dropdown-button {
    background: #262624;
    border: 1px solid var(--border-color);
    color: #fff;
    font-family: 'Poppins', sans-serif;
    font-size: 0.9rem;
    cursor: pointer;
    padding: 0.5rem;
    border-radius: 10px;
    transition: color 0.3s ease, border-color 0.3s ease;
    display: flex;
    align-items: center;
    bottom: 100%; /* Открываем вверх */
    top: auto; /* Убираем привязку к нижней части */
    gap: 0.5rem;
    width: 110px; /* Фиксированная ширина */
    justify-content: center;
}

.dropdown-button:hover {
    color: var(--accent-color);
    border-color: var(--accent-color);
}

.dropdown-button.active {
    border-color: var(--accent-color);
    color: var(--accent-color);
}

.dropdown-button svg {
    width: 16px;
    height: 16px;
    transition: transform 0.3s ease;
    flex-shrink: 0; /* Предотвращает сжатие иконки */
}

#selected-model {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100px; /* Максимальная ширина текста */
}

.dropdown-button.active svg {
    transform: rotate(180deg);
}

.dropdown-menu {
    position: absolute;
    left: 0;
    background: var(#1d1f20);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    display: none;
    z-index: 1000;
    min-width: 100%;
    top: auto;
    bottom: auto;
}

.dropdown-menu.active {
    display: block;
}

.dropdown-item {
    padding: 0.5rem;
    color: var(--text-color);
    cursor: pointer;
    transition: background 0.3s ease, color 0.3s ease;
}

.dropdown-item:hover {
    background: var(--hover-color);
    color: var(--accent-color);
}

.send-button {
    background: var(--send-btn-color);
    border: none;
    padding: 0.75rem;
    border-radius: 50px;
    cursor: pointer;
    align-items: center;
    justify-content: center;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(87, 89, 217, 0.2);
    min-width: 44px;
}
.send-button:active {
    transform: translateY(1px);
    box-shadow: 0 2px 4px rgba(87, 89, 217, 0.2);
}

.send-button svg {
    width: 24px;
    height: 24px;
    fill: #FFFFFF;
}

.send-button.sending {
    background: linear-gradient(135deg, #FF0000, #3A3B44);
}

.send-button.sending:hover {
    background: linear-gradient(135deg, #CC0000, #3A3B44);
}

.send-button.disabled {
    background: var(--border-color);
    cursor: not-allowed;
}

.send-button.disabled:hover {
    background: var(--border-color);
}

.file-input {
    display: none;
}

.drag-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    font-family: 'Poppins', sans-serif;
    color: var(--text-color);
    text-align: center;
}

.drag-overlay.active {
    display: flex;
}

.drag-overlay-content {
    background: var(--primary-bg);
    padding: 2rem;
    border-radius: 20px;
    border: 1px dashed var(--accent-color);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
}

.drag-overlay-content svg {
    width: 40px;
    height: 40px;
    fill: var(--accent-color);
}

.drag-overlay-content h3 {
    margin: 0;
    font-size: 1.2rem;
    font-weight: 500;
}

.drag-overlay-content p {
    margin: 0;
    font-size: 0.9rem;
    color: var(--text-color);
}

.file-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10001;
}

.file-modal-overlay.active {
    display: flex;
}

.file-modal-content {
    background: var(--primary-bg);
    padding: 2rem;
    border-radius: 20px;
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    gap: 1rem;
    width: 90%;
    max-width: 500px;
    position: relative;
}

.file-modal-content h3 {
    margin: 0;
    font-size: 1.2rem;
    font-weight: 500;
    color: var(--text-color);
}

.file-modal-buttons {
    display: flex;
    gap: 1rem;
    justify-content: center;
}

.file-modal-btn {
    background: transparent;
    border: 1px solid var(--border-color);
    color: var(--text-color);
    padding: 0.75rem 1.5rem;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 1rem;
}

.file-modal-btn:hover {
    border-color: var(--accent-color);
    color: var(--accent-color);
}

.close-file-modal-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    background: transparent;
    border: none;
    color: var(--text-color);
    cursor: pointer;
    padding: 0.5rem;
}

.close-file-modal-btn svg {
    width: 20px;
    height: 20px;
}

.close-file-modal-btn:hover {
    color: var(--close-btn-color);
}

.camera-feed-container {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
}

.camera-feed-container.active {
    display: flex;
}

.camera-feed {
    width: 100%;
    max-width: 400px;
    border-radius: 10px;
    background: #000;
}

.capture-btn {
    background: var(--accent-color);
    border: none;
    color: #fff;
    padding: 0.75rem 1.5rem;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 1rem;
}

.capture-btn:hover {
    background: var(--send-btn-hover-color);
}

.scroll-down-btn {
    position: absolute;
    right: 1px;
    margin-right: 30em;
    bottom: 60px;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--send-btn-color);
    border: none;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.3s ease, bottom 0.3s ease, transform 0.3s ease;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.scroll-down-btn.visible {
    opacity: 1;
}

.scroll-down-btn:hover {
    transform: scale(1.1);
}

.scroll-down-btn svg {
    stroke: #fff;
    width: 24px;
    height: 24px;
}

.attachment-item.loading {
    position: relative;
}

.attachment-item.loading img {
    opacity: 0.5;
    transition: opacity 0.3s ease;
}

.attachment-item.loading .attachment-icon {
    opacity: 0.5;
    transition: opacity 0.3s ease;
}

.attachment-loading-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.attachment-loading-spinner {
    width: 16px;
    height: 16px;
    border: 2px solid var(--text-color);
    border-top: 2px solid var(--accent-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.greeting svg {
    width: 45px;
    height: 45px;
    fill: none;
    stroke: var(--accent-color);
}

.user-message-action-btn svg,
.assistant-message-action-btn svg {
    width: 12px;
    height: 12px;
}

.send-button svg {
    width: 20px;
    height: 18px;
}

/* File Preview Styles */

.file-preview-pdf-container {
    width: 100%;
    height: 100%;
    position: relative;
    background-color:black;
}
/* Стили для звездного неба */
#starry-sky {
    display: block;
    position: fixed;
    inset: 0;
    z-index: -1000; /* Размещаем под всем контентом */
    opacity: 0; /* Начинаем с невидимого состояния */
    transition: opacity 1.5s ease; /* Плавное появление/исчезновение */
    pointer-events: none; /* Позволяет кликать сквозь canvas */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

/* Стили для затемнения фона при активном звездном небе */
body.starry-sky-active {
    /* Убираем изменение фона, чтобы не влиять на основной интерфейс */
    /* background: rgba(5, 6, 10, 0.95); */
    /* transition: background 1.5s ease; */
}

/* Адаптивные стили для разных устройств */
@media screen and (max-width: 1024px) {
    .file-preview-pdf-container {
        height: 35rem;
    }
}

@media screen and (max-width: 768px) {
    .file-preview-pdf-container {
        height: 30rem;
    }
}

@media screen and (max-width: 480px) {
    .file-preview-pdf-container {
        height: 25rem;
    }
}

.file-preview-pdf-container .release-object-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    padding: 0.5rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.file-preview-text-container,
.file-preview-code-container,
.file-preview-markdown-container {
    padding: 0.3rem;
    background: #101212;
    font-family: 'Courier New', monospace;
    width: 53rem;
}
.file-preview-code-container pre {
    color: #fff;
}
 /* Стили для бокового окна предпросмотра */
 .file-preview-sidebar {
    position: fixed;
    top: 0;
    right: 0;
    width: 400px;
    height: 100%;
    transform: translateX(100%);
    transition: transform 0.3s ease;
    z-index: 900;
    display: flex;
    flex-direction: column;
        }
        #file-preview-title {
            padding-left: 15px;
            font-size: 1.2rem;
            font-weight: 600;
            color: #fff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #file-preview-close-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            color: #fff;
            transition: color 0.2s ease;
        }
        #file-preview-close-btn:hover {
            color: #666;
        }
        #file-preview-close-btn svg {
            width: 20px;
            height: 20px;
        }
        .file-preview-pdf-container object {
            width: 100%;
            height: 100%;
            border: none;
        }
        .file-preview-sidebar.active {
            transform: translateX(0);
        }

        .file-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            background-color: #000;
        }

        .file-preview-close-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            color: white;
        }

        .file-preview-content {
            flex: 1;
            overflow-y: auto;
            word-wrap: break-word;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.5;
            height: calc(100vh - 60px);
            padding-left: 0.5rem;
            background-color: #000;

        }

        .file-preview-content iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .file-preview-content object {
            border: none;
            margin: 0;
            padding: 0;
        }
        .file-preview-error {
            color: #e74c3c;
            font-style: italic;
        }
/* Стили для прокрутки */
.file-preview-content::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.file-preview-content::-webkit-scrollbar-track {
    background: #101212;
    position: relative;
}

/* Треугольники для вертикального скроллбара */
.file-preview-content::-webkit-scrollbar-track::before {
    content: '';
    position: absolute;
    left: 50%;
    top: 2px;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
    border-bottom: 4px solid #fff;
}

.file-preview-content::-webkit-scrollbar-track::after {
    content: '';
    position: absolute;
    left: 50%;
    bottom: 2px;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 4px solid transparent;
    border-right: 4px solid transparent;
    border-top: 4px solid #fff;
}

/* Треугольники для горизонтального скроллбара */
.file-preview-content::-webkit-scrollbar-track:horizontal::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 2px;
    transform: translateY(-50%);
    width: 0;
    height: 0;
    border-top: 4px solid transparent;
    border-bottom: 4px solid transparent;
    border-right: 4px solid #fff;
}

.file-preview-content::-webkit-scrollbar-track:horizontal::after {
    content: '';
    position: absolute;
    top: 50%;
    right: 2px;
    transform: translateY(-50%);
    width: 0;
    height: 0;
    border-top: 4px solid transparent;
    border-bottom: 4px solid transparent;
    border-left: 4px solid #fff;
}

/* Устранение белого квадратика в пересечении */
.file-preview-content::-webkit-scrollbar-corner {
    background: #101212; /* Устанавливаем тот же фон, что и у трека */
}

.file-preview-content::-webkit-scrollbar-thumb {
    background-color: #333;
    border-radius: 4px;
}

.file-preview-content::-webkit-scrollbar-thumb:hover {
    background-color: #555;
}
@media (min-width: 1440px) {
    body {
        font-size: 16px;
    }
    .sidebar {
        width: 300px;
    }
    .chat-messages {
        width: 70%;
        max-width: 900px;
    }
    .chat-input-wrapper {
        max-width: 900px;
    }
    .scroll-down-btn {
    right: 1px;
    margin-right: 25em;
    }
}

@media (max-width: 1440px) and (min-width: 1024px) {
    .chat-input-wrapper {
        width: 80%;
        max-width: 800px;
    }
    .greeting svg {
        width: 45px;
        height: 30px;
    }
}

@media (max-width: 1024px) {
    body {
        font-size: 14px;
    }
    .sidebar {
        width: 70vw;
    }
    .chat-messages {
        width: 90%;
        max-width: 90vw;
        min-width: 280px;
        padding: 1rem;
        padding-top: 4rem;
        padding-bottom: 10rem;
    }
    .header {
        height: 48px;
    }
    .logo {
        font-size: 1.2rem;
    }
    .greeting {
        width: 500px;
        top: 35vh;
        font-size: 2.5rem;
        text-align: center;
        padding: 0 2rem;
    }
    .greeting svg {
        width: 2.5rem;
        height: 2.5rem;
    }
    .chat-input-container {
        bottom: 2rem;
        padding: 0;
    }
    .chat-input-wrapper {
        width: 90%;
        max-width: 100vw;
        min-width: 280px;
        padding: 0.8rem;
        border-radius: 1rem;
    }
    .chat-input {
        font-size: 0.9rem;
        max-height: 10rem;
    }
    .input-actions {
        gap: 0.3rem;
    }
   
    .input-icons svg,
    .dropdown-button svg,
    .send-button svg {
        width: 1.2rem;
        height: 1.2rem;
    }
    .scroll-down-btn {
        width: 2.5rem;
        height: 2.5rem;
        bottom: 7rem;
        right: 1px;
        margin-right: 5em;
    }
    .scroll-down-btn svg {
        width: 1.5rem;
        height: 1.5rem;
    }
    .message {
        padding: 0.8rem;
        margin-bottom: 2rem;
    }
    .message-content {
        font-size: 0.9rem;
    }
    .attachment-item {
        width: 10rem;
        height: 2.5rem;
    }
    .attachment-item.image {
        width: 3.5rem;
        height: 3.5rem;
    }
    .message-attachment-item {
        width: 12rem;
        height: 3rem;
    }
    .message-attachment-item.image {
        width: 3.5rem;
        height: 3.5rem;
    }
    .file-modal-content {
        width: 80%;
        max-width: 400px;
        padding: 1.5rem;
    }

}

@media (max-width: 768px) {
    body {
        font-size: 12px;
    }
    .sidebar {
        width: 100vw;
    }
    .sidebar-title {
        font-size: 1rem;
    }
    .chat-messages {
        width: 95%;
        min-width: 260px;
    }
    .header {
        height: 60px;
    }
    .logo {
        font-size: 1rem;
    }
    .greeting {
        width: 400px;
        top: 35vh;
        font-size: 2rem;
        line-height: 1.4;
        padding: 0 0.8rem;
    }
    .greeting svg {
        width: 1.8rem;
        height: 1.8rem;
    }
    .chat-input-wrapper {
        width: 90%;
        max-width: 95vw;
        min-width: 240px;
        padding: 0.6rem;
        border-radius: 0.8rem;
    }
    .chat-input {
        font-size: 0.85rem;
        max-height: 8rem;
    }
    .input-actions {
        flex-wrap: wrap;
        gap: 0.2rem;
    }
    .input-icons button,
    .dropdown-button,
    .send-button {
        padding: 0.7rem;
    }
    .send-button {
        width: 20px;
        height: 40px;
    }
    .input-icons svg,
    .dropdown-button svg,
    .send-button svg {
        width: 1.2rem;
        height: 1.2rem;
    }
    .scroll-down-btn {
        width: 2.5rem;
        height: 2.5rem;
    }
    .scroll-down-btn svg {
        width: 1.5rem;
        height: 1.5rem;
    }
    .message {
        padding: 0.6rem;
        margin-bottom: 1.5rem;
    }
    .message-content {
        font-size: 0.85rem;
    }
    .attachment-item {
        width: 8rem;
        height: 2rem;
    }
    .attachment-item.image {
        width: 3rem;
        height: 3rem;
    }
    .message-attachment-item {
        width: 10rem;
        height: 2.5rem;
    }
    .message-attachment-item.image {
        width: 3rem;
        height: 3rem;
    }
    .attachment-icon,
    .message-attachment-icon {
        width: 1.5rem;
        height: 1.5rem;
        margin-right: 0.5rem;
    }
    .attachment-name,
    .message-attachment-name {
        font-size: 0.8rem;
    }
    .attachment-name::after,
    .message-attachment-name::after {
        font-size: 0.7rem;
    }
    .file-modal-content {
        width: 90%;
        max-width: 320px;
        padding: 1rem;
    }
    .file-modal-btn {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
    }

}

@media (max-width: 480px) {
    body {
        font-size: 11px;
    }
    .sidebar {
        width: 100vw;
    }
    .sidebar-title {
        font-size: 0.9rem;
    }
    .chat-messages {
        width: 90%;
        min-width: 200px;
        padding-top: 3rem;
        padding-bottom: 7rem;
    }
    .header {
        height: 56px;
    }
    .logo {
        font-size: 0.9rem;
    }
    .greeting {
        top: 40vh;
        font-size: 1.5rem;
        line-height: 1.3;
        width: 300px;
    }
    .greeting svg {
        width: 1.8rem;
        height: 1.8rem;
    }
    .chat-input-container {
        padding: 0.3rem;
        bottom: -0.1rem;
    }
    .chat-input-wrapper {
        max-width: 100vw;
        min-width: 200px;
        padding: 0.5rem;
        border-radius: 0.6rem;
    }
    .chat-input {
        font-size: 0.8rem;
        max-height: 6rem;
    }
    .input-actions {
        gap: 0.1rem;
    }
    .input-icons button,
    .dropdown-button,
    .send-button {
        padding: 0.5rem;
    }
    .send-button {
        width: 16px;
        height: 32px;
    }
    .input-icons svg,
    .dropdown-button svg,
    .send-button svg {
        width: 0.9rem;
        height: 0.9rem;
    }
    /* Скрываем текст у кнопок DeepSearch и Think */
    .deepsearch-btn span,
    .think-btn span {
        display: none;
    }
    .scroll-down-btn {
        width: 1.8rem;
        height: 1.8rem;
        bottom: 5rem;
        right: -2em;
    }
    .scroll-down-btn svg {
        width: 1rem;
        height: 1rem;
    }
    .message.editing .message-content {
    padding: 0.3rem;
    min-height: 100px;
    min-width: 250px;
    }
    #preview-image {
        width: 20rem;
    }
    .message {
        padding: 0.5rem;
        margin-bottom: 1rem;
    }
    .message-content {
        font-size: 0.8rem;
    }
    .attachment-item {
        width: 6rem;
        height: 1.8rem;
    }
    .attachment-item.image {
        width: 2.5rem;
        height: 2.5rem;
    }
    .message-attachment-item {
        width: 8rem;
        height: 2rem;
    }
    .message-attachment-item.image {
        width: 2.5rem;
        height: 2.5rem;
    }
    .attachment-icon,
    .message-attachment-icon {
        width: 1.2rem;
        height: 1.2rem;
        margin-right: 0.3rem;
    }
    .attachment-name,
    .message-attachment-name {
        font-size: 0.7rem;
    }
    .attachment-name::after,
    .message-attachment-name::after {
        font-size: 0.6rem;
    }
    .file-modal-content {
        width: 95%;
        max-width: 280px;
        padding: 0.8rem;
    }
    .file-modal-btn {
        padding: 0.4rem 0.8rem;
        font-size: 0.8rem;
    }

}

    </style>
</head>
<body>
    <div class="app-container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">Chat history</div>
                <div class="sidebar-actions">
                    <button class="sidebar-action-btn" id="new-chat-btn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                            <path d="M12 4v16m8-8H4" stroke="currentColor" stroke-width="2"/>
                        </svg>
                    </button>
                    <button class="sidebar-action-btn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                            <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" stroke="currentColor" stroke-width="2"/>
                        </svg>
                    </button>
                    <button class="sidebar-action-btn" id="close-sidebar-btn">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                            <path d="M3 3L13 13M3 13L13 3" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="chat-list" id="chat-list"></div>
            <div class="user-info" id="user-info">
                <svg class="user-icon" width="20" height="20" viewBox="0 0 24 24" fill="none">
                    <path d="M12 12a4 4 0 100-8 4 4 0 000 8zm-7 4h14v-1a4 4 0 00-4-4H9a4 4 0 00-4 4v1z" stroke="currentColor" stroke-width="2"/>
                </svg>
                <span class="user-name">User</span>
                <button class="settings-btn">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                        <path d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" stroke="currentColor" stroke-width="2"/>
                    </svg>
                </button>
            </div>
        </aside>

        <header class="header">
            <div class="header-actions">
                <button class="action-btn" id="open-sidebar-btn">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M3 3H13M3 8H13M3 13H13" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                </button>
            </div>
            <div class="logo">Veronica AI</div>
            <div class="header-actions"></div>
        </header>

        <div class="scroll-container">
            <div class="chat-messages" id="chat-messages"></div>
        </div>

        <div class="greeting" id="greeting">
            <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M15 16.5001C15.8284 16.5001 16.5 15.8285 16.5 15.0001C16.5 14.1716 15.8284 13.5001 15 13.5001C14.1715 13.5001 13.5 14.1716 13.5 15.0001C13.5 15.8285 14.1715 16.5001 15 16.5001Z" stroke="#5759D9" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M27.3 27.3001C30.36 24.2551 27.33 16.2601 20.55 9.45007C13.74 2.67007 5.74495 -0.359927 2.69995 2.70007C-0.360049 5.74507 2.66995 13.7401 9.44995 20.5501C16.26 27.3301 24.255 30.3601 27.3 27.3001Z" stroke="#5759D9" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M20.55 20.5501C27.33 13.7401 30.36 5.74507 27.3 2.70007C24.255 -0.359927 16.26 2.67007 9.44995 9.45007C2.66995 16.2601 -0.360049 24.2551 2.69995 27.3001C5.74495 30.3601 13.74 27.3301 20.55 20.5501Z" stroke="#5759D9" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>                
            <span id="greeting-text"><span class="greeting-time">Good morning</span>, <span class="greeting-user">User</span>!</span>
        </div>

        <div class="chat-input-container" id="chat-input-container">
            <div class="chat-input-wrapper">
                <div class="attachment-list" id="attachment-list"></div>
                <div class="chat-input-area">
                    <textarea 
                        class="chat-input" 
                        id="message-input" 
                        placeholder="How can I assist you?"
                        rows="1"
                    ></textarea>
                </div>
                <div class="input-actions">
                    <div class="input-icons">
                        <button class="files-btn">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                                <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8l-6-6z" stroke="currentColor" stroke-width="2"/>
                                <path d="M14 2v6h6" stroke="currentColor" stroke-width="2"/>
                            </svg>
                            <!-- Files -->
                        </button>
                        <button class="image-gen-btn">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                                <path d="M19 3H5a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2V5a2 2 0 00-2-2z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M8.5 10a1.5 1.5 0 100-3 1.5 1.5 0 000 3z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                <path d="M21 15l-5-5L5 21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            <!-- Image Generation -->
                        </button>
                         <button class="deepsearch-btn">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M12 11.3201H8.00671C7.27337 11.3201 6.70671 11.9468 6.35337 12.5868C6.07368 13.1116 5.62657 13.5279 5.08312 13.7694C4.53968 14.011 3.93108 14.0639 3.35409 13.9199C2.77709 13.7758 2.26481 13.443 1.89867 12.9744C1.53254 12.5057 1.33356 11.9282 1.33337 11.3335C1.34004 10.8668 1.46671 10.4001 1.71337 10.0001M4.00004 11.3335L6.08671 7.48012C6.44004 6.83345 6.15337 6.02679 5.75337 5.41345C5.56458 5.11152 5.43818 4.77483 5.38161 4.42326C5.32505 4.07168 5.33947 3.71234 5.42403 3.36643C5.50859 3.02052 5.66158 2.69505 5.87396 2.40922C6.08635 2.12339 6.35383 1.88299 6.66062 1.70221C6.96742 1.52143 7.30731 1.40393 7.66025 1.35663C8.01319 1.30934 8.37203 1.33321 8.7156 1.42684C9.05917 1.52048 9.3805 1.68197 9.66064 1.9018C9.94078 2.12163 10.1741 2.39534 10.3467 2.70679M8.00004 4.00012L10.0867 7.82012C10.44 8.46679 11.2667 8.66679 12 8.66679C12.7073 8.66679 13.3856 8.94774 13.8857 9.44783C14.3858 9.94793 14.6667 10.6262 14.6667 11.3335C14.6667 12.0407 14.3858 12.719 13.8857 13.2191C13.3856 13.7192 12.7073 14.0001 12 14.0001" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            <span>DeepSearch</span>
                        </button>
                        <button class="think-btn">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M10 9.33325C10.1333 8.66658 10.4667 8.19992 11 7.66658C11.6667 7.06658 12 6.19992 12 5.33325C12 4.27239 11.5786 3.25497 10.8284 2.50482C10.0783 1.75468 9.06087 1.33325 8 1.33325C6.93913 1.33325 5.92172 1.75468 5.17157 2.50482C4.42143 3.25497 4 4.27239 4 5.33325C4 5.99992 4.13333 6.79992 5 7.66658C5.46667 8.13325 5.86667 8.66658 6 9.33325M6 11.9999H10M6.66667 14.6666H9.33333" stroke="currentColor" stroke-opacity="0.733333" stroke-linecap="round" stroke-linejoin="round"/>
                            </svg>
                            <span>Think</span>
                        </button>

                    </div>
                    <div class="input-right">
                        <div class="custom-dropdown">
                            <button class="dropdown-button" id="dropdown-button">
                                <span id="selected-model">Veronica Pro</span>
                                <svg viewBox="0 0 16 16" fill="none">
                                    <path d="M4 6L8 10L12 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                            <div class="dropdown-menu" id="dropdown-menu"></div>
                        </div>
                        <button class="send-button" id="send-button">
                            <svg width="20" height="18" viewBox="0 0 17 18" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M4.28162 9L8.95524 3.75M8.95524 3.75L13.6289 9M8.95524 3.75V14.25" stroke="#fff" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                                
                        </button>
                    </div>
                </div>
                <button class="scroll-down-btn">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M12 4v12m-6-6l6 6l6-6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
            </div>
        </div>

        <div class="drag-overlay" id="drag-overlay">
            <div class="drag-overlay-content">
                <svg viewBox="0 0 24 24">
                    <path d="M12 4v16m8-8H4" stroke="currentColor" stroke-width="2"/>
                </svg>
                <h3>Перетащи свой файл сюда</h3>
                <p>Перетащи свой файл сюда, чтобы добавить их в разбор</p>
            </div>
        </div>

        <div class="image-preview-overlay" id="image-preview-overlay">
            <div class="image-preview-content">
                <button class="close-preview-btn" id="close-preview-btn">
                    <svg viewBox="0 0 24 24" fill="none">
                        <path d="M6 18L18 6M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <img id="preview-image" src="" alt="Image Preview">
            </div>
        </div>



        <div class="file-modal-overlay" id="file-modal-overlay">
            <div class="file-modal-content">
                <button class="close-file-modal-btn" id="close-file-modal-btn">
                    <svg viewBox="0 0 24 24" fill="none">
                        <path d="M6 18L18 6M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <h3>Choose upload method</h3>
                <div class="file-modal-buttons">
                    <button class="file-modal-btn" id="upload-from-device-btn">Upload from device</button>
                    <button class="file-modal-btn" id="capture-from-camera-btn">Take a photo</button>
                </div>
                <div class="camera-feed-container" id="camera-feed-container">
                    <video id="camera-feed" class="camera-feed" autoplay></video>
                    <button class="capture-btn" id="capture-btn">Take a photo</button>
                </div>
            </div>
        </div>

        <input type="file" id="file-input" class="file-input" multiple>
        <canvas id="camera-canvas" style="display: none;"></canvas>
    </div>

    <div class="file-preview-sidebar" id="file-preview-sidebar">
        <div class="file-preview-header">
            <h3 id="file-preview-title">File Preview</h3>
            <button class="file-preview-close-btn" id="file-preview-close-btn">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                    <path d="M6 18L18 6M6 6l12 12" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
        </div>
        <div class="file-preview-content" id="file-preview-content">
            <!-- Содержимое файла будет здесь -->
        </div>
    </div>

       
 <script>
    document.addEventListener('DOMContentLoaded', async () => {
    // Инициализация DOM-элементов
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    const chatMessages = document.getElementById('chat-messages');
    const scrollContainer = document.querySelector('.scroll-container');
    const chatInputContainer = document.getElementById('chat-input-container');
    const chatInputWrapper = document.querySelector('.chat-input-wrapper');
    const sidebar = document.getElementById('sidebar');
    const openSidebarBtn = document.getElementById('open-sidebar-btn');
    const closeSidebarBtn = document.getElementById('close-sidebar-btn');
    const chatList = document.getElementById('chat-list');
    const newChatBtn = document.getElementById('new-chat-btn');
    const dropdownButton = document.getElementById('dropdown-button');
    const dropdownMenu = document.getElementById('dropdown-menu');
    const selectedModel = document.getElementById('selected-model');
    const greeting = document.getElementById('greeting');
    const greetingText = document.getElementById('greeting-text');
    const settingsBtn = document.querySelector('.settings-btn');
    const userInfo = document.getElementById('user-info');
    const thinkBtn = document.querySelector('.think-btn');
    const fileInput = document.getElementById('file-input');
    const attachmentList = document.getElementById('attachment-list');
    const dragOverlay = document.getElementById('drag-overlay');
    const imagePreviewOverlay = document.getElementById('image-preview-overlay');
    const previewImage = document.getElementById('preview-image');
    const closePreviewBtn = document.getElementById('close-preview-btn');
    const fileModalOverlay = document.getElementById('file-modal-overlay');
    const closeFileModalBtn = document.getElementById('close-file-modal-btn');
    const uploadFromDeviceBtn = document.getElementById('upload-from-device-btn');
    const captureFromCameraBtn = document.getElementById('capture-from-camera-btn');
    const cameraFeedContainer = document.getElementById('camera-feed-container');
    const cameraFeed = document.getElementById('camera-feed');
    const captureBtn = document.getElementById('capture-btn');
    const cameraCanvas = document.getElementById('camera-canvas');


    // Новые элементы для бокового окна предпросмотра
    const filePreviewSidebar = document.getElementById('file-preview-sidebar');
    const filePreviewTitle = document.getElementById('file-preview-title');
    const filePreviewContent = document.getElementById('file-preview-content');
    const filePreviewCloseBtn = document.getElementById('file-preview-close-btn');

    // Создание кнопки прокрутки вниз, если она отсутствует
    let scrollDownButton = document.querySelector('.scroll-down-btn');
    if (!scrollDownButton) {
        scrollDownButton = document.createElement('button');
        scrollDownButton.className = 'scroll-down-btn';
        scrollDownButton.innerHTML = `
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                <path d="M12 4v12m-6-6l6 6l6-6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        `;
        chatInputWrapper.appendChild(scrollDownButton);
    }

    // Инициализация переменных состояния
    let isFirstMessage = true;
    let isSidebarOpen = false;
    let isDropdownOpen = false;
    let currentChatId = null;
    let thinkActive = false;
    let isStreaming = false;
    let stopStream = false;
    let abortController = null;
    let isTyping = false;
    let models = [];
    let imageGenModels = [];
    let thinkModel = '';
    let multimodalModel = '';
    let deepSearchActive = false; // Флаг для отслеживания активации режима DeepSearch
    let imageGenActive = false; // Флаг для отслеживания активации режима генерации изображений
    let attachedFiles = [];
    let isDragging = false;
    let disableAutoScroll = false;
    let uploadedFiles = new Map();
    let ongoingUploads = 0;
    let cameraStream = null;
    let dragCounter = 0;

    // Поддерживаемые форматы файлов
    const supportedImageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp'];
    const supportedDocumentExtensions = [
        'pdf', 'txt', 'docx', 'odt', 'xlsx', 'ods', 'rtf', 'csv',
        'html', 'css', 'js', 'json', 'xml', 'yaml', 'yml', 'md',
        'py', 'java', 'cpp', 'c', 'cs', 'sql', 'sh', 'bat', 'ts',
        'jsx', 'tsx', 'php', 'log', 'ini', 'tex', 'bib'
    ];

    // Индикаторы загрузки и обработки
    const processingIndicator = document.createElement('div');
    processingIndicator.className = 'processing-indicator';
    processingIndicator.innerHTML = `
        <div class="processing-dot"></div>
        <div class="processing-dot"></div>
        <div class="processing-dot"></div>
    `;

    const thinkingIndicator = document.createElement('div');
    thinkingIndicator.className = 'thinking-indicator';
    thinkingIndicator.innerHTML = `
        <div class="thinking-spinner"></div>
        <span class="thinking-time">Thinking... 1s</span>
    `;
    
    // Индикатор для DeepSearch
    const deepSearchIndicator = document.createElement('div');
    deepSearchIndicator.className = 'deepsearch-indicator';
    deepSearchIndicator.innerHTML = `
        <div class="deepsearch-spinner"></div>
        <span class="deepsearch-text">Searching...</span>
    `;
    
    // Индикатор для генерации изображений
    const imageGenIndicator = document.createElement('div');
    imageGenIndicator.className = 'image-gen-indicator';
    imageGenIndicator.innerHTML = `
        <div class="image-gen-spinner"></div>
        <span class="image-gen-text">Generating image...</span>
    `;

    // Функция для открытия бокового окна предпросмотра
    async function openFilePreview(fileName, fileUrl = null, file = null) {
    filePreviewTitle.textContent = fileName;
    filePreviewContent.innerHTML = '<p>Loading...</p>';

    filePreviewSidebar.classList.add('active');

    try {
        const extension = fileName.split('.').pop().toLowerCase();

        if (extension === 'pdf') {
            let pdfUrl;
            let revokeUrl = false;

            if (file) {
                // Локальный PDF (до загрузки)
                pdfUrl = URL.createObjectURL(file);
                revokeUrl = true;
            } else if (fileUrl) {
                // Загруженный PDF
                pdfUrl = fileUrl;
            } else {
                throw new Error('Не удалось определить источник PDF-файла');
            }

            // Используем <object> для рендеринга PDF
            filePreviewContent.innerHTML = `
                <div class="file-preview-pdf-container">
                    <object data="${pdfUrl}" type="application/pdf" width="100%" height="100%" >
                        <p>Ваш браузер не поддерживает отображение PDF. 
                        <a href="${pdfUrl}" target="_blank">Скачайте файл</a> для просмотра.</p>
                    </object>
                </div>
            `;

            if (revokeUrl) {
                // Ждем загрузки PDF перед освобождением URL
                const pdfObject = filePreviewContent.querySelector('object');
                pdfObject.onload = () => {
                    URL.revokeObjectURL(pdfUrl);
                };
            }
        } else {
            // Обработка текстовых файлов
            let content;
            if (file) {
                content = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            } else if (fileUrl) {
                const response = await fetch(fileUrl);
                if (!response.ok) throw new Error('Не удалось загрузить содержимое файла');
                content = await response.text();
            } else {
                throw new Error('Не удалось определить источник файла');
            }

            // Определяем тип файла для выбора класса
            let containerClass = 'file-preview-text-container';
            if (['py', 'java', 'cpp', 'c', 'cs', 'js', 'ts', 'jsx', 'tsx', 'php'].includes(extension)) {
                containerClass = 'file-preview-code-container';
            } else if (extension === 'md') {
                containerClass = 'file-preview-markdown-container';
            }

            // Создаем контейнер с соответствующим классом
            const container = document.createElement('div');
            container.className = containerClass;

            // Экранируем содержимое для безопасного отображения
            if (extension === 'md') {
                container.innerHTML = marked.parse(content);
            } else {
                const pre = document.createElement('pre');
                const code = document.createElement('code');
                code.textContent = content;
                pre.appendChild(code);
                container.appendChild(pre);
            }

            filePreviewContent.innerHTML = '';
            filePreviewContent.appendChild(container);
        }
    } catch (error) {
        console.error('Error loading file preview:', error);
        filePreviewContent.innerHTML = `<p class="file-preview-error">Error loading file: ${error.message}</p>`;
    }
}

    // Функция для закрытия бокового окна предпросмотра
    function closeFilePreview() {
        filePreviewSidebar.classList.remove('active');
        filePreviewContent.innerHTML = '';
        filePreviewTitle.textContent = 'File Preview';
    }

    // Обновление состояния кнопки отправки
    function updateSendButton() {
        const hasAttachments = attachedFiles.length > 0;
        const isProcessing = (isStreaming || isTyping);

        if (isProcessing) {
            sendButton.innerHTML = `
                <svg class="stop-icon" width="20" height="20" viewBox="0 0 24 24" fill="#FFFFFF">
                    <rect x="8" y="8" width="8" height="8" fill="#FFFFFF"/>
                </svg>
            `;
            sendButton.classList.add('sending');
            sendButton.disabled = false;
            sendButton.style.opacity = '1';
        } else if (hasAttachments && ongoingUploads === 0) {
            sendButton.innerHTML = `
                <svg width="20" height="18" viewBox="0 0 17 18" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M4.28162 9L8.95524 3.75M8.95524 3.75L13.6289 9M8.95524 3.75V14.25" stroke="#fff" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            `;
            sendButton.classList.remove('sending');
            sendButton.disabled = false;
            sendButton.style.opacity = '1';
        } else if (hasAttachments) {
            sendButton.innerHTML = `
                <svg width="20" height="18" viewBox="0 0 17 18" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M4.28162 9L8.95524 3.75M8.95524 3.75L13.6289 9M8.95524 3.75V14.25" stroke="#fff" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            `;
            sendButton.classList.remove('sending');
            sendButton.disabled = true;
            sendButton.style.opacity = '0.5';
        } else {
            sendButton.innerHTML = `
                <svg width="20" height="18" viewBox="0 0 17 18" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M4.28162 9L8.95524 3.75M8.95524 3.75L13.6289 9M8.95524 3.75V14.25" stroke="#fff" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            `;
            sendButton.classList.remove('sending');
            sendButton.disabled = false;
            sendButton.style.opacity = '1';
        }
    }

    // Загрузка файла на сервер
    async function uploadFile(file) {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('chat_id', currentChatId || '');

        const filename = file.name.toLowerCase();
        const isImage = supportedImageExtensions.includes(filename.split('.').pop());
        const endpoint = isImage ? '/veronica/upload-image' : '/veronica/upload-document';

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error(`Failed to upload file: ${response.status}`);
            }

            const data = await response.json();
            console.log(`Uploaded ${file.name} to ${data.url}`);
            return { name: file.name, url: data.url };
        } catch (error) {
            console.error('Upload error:', error);
            appendMessage('assistant', `Error loading file "${file.name}": ${error.message}`, true, [], true);
            return null;
        }
    }

    // Отображение вложения в интерфейсе
    async function showAttachment(file) {
        const extension = file.name.split('.').pop().toLowerCase();
        const isImage = supportedImageExtensions.includes(extension);
        const attachmentItem = document.createElement('div');
        attachmentItem.className = `attachment-item ${isImage ? 'image' : 'file'} loading`;
        attachmentItem.dataset.fileName = file.name;

        const loadingIndicator = document.createElement('div');
        loadingIndicator.className = 'attachment-loading-indicator';
        loadingIndicator.innerHTML = `<div class="attachment-loading-spinner"></div>`;

        const contentDiv = document.createElement('div');
        contentDiv.className = 'attachment-content';

        const fileInfo = document.createElement('div');
        fileInfo.className = 'file-info';
        fileInfo.style.display = 'flex';
        fileInfo.style.alignItems = 'center';
        fileInfo.style.gap = '8px';

        const fileIcon = document.createElement('span');
        fileIcon.innerHTML = `
            <svg class="attachment-icon" viewBox="0 0 24 24" fill="none">
                <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8l-6-6z" stroke="currentColor" stroke-width="2"/>
                <path d="M14 2v6h6" stroke="currentColor" stroke-width="2"/>
            </svg>
        `;

        const fileName = document.createElement('span');
        fileName.className = 'attachment-name';
        fileName.textContent = file.name;

        fileInfo.appendChild(fileIcon);
        fileInfo.appendChild(fileName);

        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-attachment-btn';
        removeBtn.innerHTML = `
            <svg viewBox="0 0 16 16" fill="none">
                <path d="M3 3L13 13M3 13L13 3" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
        `;

        contentDiv.appendChild(fileInfo);
        contentDiv.appendChild(removeBtn);

        if (isImage) {
            const reader = new FileReader();
            reader.onload = (e) => {
                fileInfo.innerHTML = `
                    <img src="${e.target.result}" alt="${file.name}" style="object-fit: contain; border-radius: 10px; cursor: pointer;">
                `;
                fileInfo.querySelector('img').addEventListener('click', () => {
                    previewImage.src = e.target.result;
                    imagePreviewOverlay.classList.add('active');
                });
            };
            reader.readAsDataURL(file);
        }

        attachmentItem.appendChild(contentDiv);
        attachmentItem.appendChild(loadingIndicator);
        attachmentList.appendChild(attachmentItem);

        ongoingUploads++;
        updateSendButton();

        const uploadedFile = await uploadFile(file);
        if (uploadedFile) {
            attachmentItem.classList.remove('loading');
            attachmentItem.removeChild(loadingIndicator);
            uploadedFiles.set(file.name, uploadedFile.url);

            if (isImage) {
                const img = contentDiv.querySelector('img');
                img.src = uploadedFile.url;
                img.style.opacity = '1';
                img.addEventListener('click', () => {
                    previewImage.src = img.src;
                    imagePreviewOverlay.classList.add('active');
                });
            } else {
                const textWidth = fileName.scrollWidth + fileIcon.scrollWidth + 40;
                attachmentItem.style.width = Math.min(Math.max(textWidth, 150), 500) + 'px';

                // Добавляем обработчик клика для предпросмотра текстовых файлов
                if (supportedDocumentExtensions.includes(extension)) {
                    attachmentItem.addEventListener('click', (e) => {
                        if (e.target.closest('.remove-attachment-btn')) return;
                        openFilePreview(file.name, null, file);
                    });
                }
            }

            removeBtn.addEventListener('click', () => {
                attachedFiles = attachedFiles.filter(f => f.name !== file.name);
                uploadedFiles.delete(file.name);
                attachmentItem.remove();
                updateSendButton();
            });
        } else {
            attachmentItem.remove();
            attachedFiles = attachedFiles.filter(f => f.name !== file.name);
            ongoingUploads--;
            updateSendButton();
            return;
        }

        ongoingUploads--;
        updateSendButton();
    }

    // Очистка вложений
    function clearAttachments() {
        attachedFiles = [];
        uploadedFiles.clear();
        attachmentList.innerHTML = '';
        fileInput.value = '';
        ongoingUploads = 0;
        updateSendButton();
    }

    // Отображение ошибки
    function showError(message) {
        const notification = document.createElement('div');
        notification.className = 'error-notification';
        notification.textContent = message;
        document.body.appendChild(notification);

        setTimeout(() => {
            notification.classList.add('show');
        }, 100);

        setTimeout(() => {
            notification.classList.remove('show');
            setTimeout(() => {
                notification.remove();
            }, 500);
        }, 3000);
    }

    // Проверка расширения файла
    function validateFileExtension(file) {
        const filename = file.name.toLowerCase();
        const extension = filename.split('.').pop();
        return supportedImageExtensions.includes(extension) || supportedDocumentExtensions.includes(extension);
    }

    // Проверка валидности загрузки файла
    function validateFileUpload(file) {
        const isImage = file.type.startsWith('image/');
        const currentImages = attachedFiles.filter(f => f.type.startsWith('image/')).length;
        const currentFiles = attachedFiles.filter(f => !f.type.startsWith('image/')).length;

        if (currentFiles > 0) {
            showError('После добавления файла нельзя добавлять другие файлы или изображения.');
            return false;
        }

        if (currentImages > 0 && !isImage) {
            showError('После добавления изображений нельзя добавлять файлы.');
            return false;
        }

        if (isImage && currentImages >= 3) {
            showError('Можно добавить не более 3 изображений.');
            return false;
        }

        return true;
    }



    // Загрузка списка моделей
    async function loadModels() {
        try {
            const response = await fetch('/veronica/models');
            if (!response.ok) throw new Error('Failed to fetch models');
            const data = await response.json();
            models = data.default_models;
            imageGenModels = data.image_gen_models || [];
            thinkModel = data.think_model;
            multimodalModel = data.multimodal_model;

            // Функция для обновления dropdown-menu в зависимости от активного режима
            function updateDropdownMenu(modelsList) {
                dropdownMenu.innerHTML = '';
                modelsList.forEach(model => {
                    const item = document.createElement('div');
                    item.className = 'dropdown-item';
                    item.setAttribute('data-value', model.id);
                    item.textContent = model.name;
                    dropdownMenu.appendChild(item);

                    item.addEventListener('click', () => {
                        selectedModel.textContent = model.name;
                        selectedModel.dataset.model = model.id;
                        isDropdownOpen = false;
                        dropdownMenu.classList.remove('active');
                        dropdownButton.classList.remove('active');
                    });
                });
            }

            // Изначально загружаем модели для текстового чата
            updateDropdownMenu(models);
            selectedModel.textContent = 'Veronica';
            selectedModel.dataset.model = 'veronica';

            // Обработчик для переключения моделей при активации/деактивации режима генерации изображений
            // теперь находится в основном обработчике клика на кнопку imageGenBtn
        } catch (error) {
            console.error('Error loading models:', error);
            appendMessage('assistant', 'Error loading models. Please try again later.', true, [], true);
        }
    }

    // Создание нового чата с повторными попытками
    async function createChatWithRetry(maxRetries = 3, delay = 1000) {
        let attempt = 0;
        while (attempt < maxRetries) {
            try {
                const response = await fetch('/veronica/chat', { method: 'POST' });
                if (!response.ok) {
                    throw new Error(`Failed to create chat: ${response.status} ${response.statusText}`);
                }
                const chat = await response.json();
                return chat.chat_id;
            } catch (error) {
                attempt++;
                if (attempt === maxRetries) {
                    console.error(`All ${maxRetries} attempts to create chat failed:`, error);
                    throw error;
                }
                console.warn(`Attempt ${attempt} failed, retrying in ${delay}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }

    // Отправка сообщения
    async function sendMessage() {
        const message = messageInput.value.trim();
        if (!message && attachedFiles.length === 0) return;
        if (attachedFiles.length > 0 && ongoingUploads > 0) return;

        messageInput.value = '';
        messageInput.style.height = 'auto';

        // Скрываем приветствие при любом первом запросе
        if (greeting.classList.contains('visible')) {
            greeting.classList.add('hidden');
            greeting.classList.remove('visible');
            chatInputContainer.classList.add('moved');
        }

        if (isFirstMessage || !currentChatId) {
            try {
                currentChatId = await createChatWithRetry();
                isFirstMessage = false;
                // Обновляем список чатов после создания нового чата
                await loadChatHistory();
            } catch (error) {
                console.error('Error creating chat after retries:', error);
                appendMessage('assistant', `Error creating chat: ${error.message}. Please try again later.`, true, [], true);
                return;
            }
        }

        // Если активен режим генерации изображений, отправляем запрос на генерацию
        if (imageGenActive && message) {
            await sendImageGenerationQuery(message);
            return;
        }

        const attachmentUrls = attachedFiles.map(file => ({
            name: file.name,
            url: uploadedFiles.get(file.name)
        })).filter(url => url.url);

        console.log('Attachment URLs before sending:', attachmentUrls);

        if (message) {
            appendMessage('user', message, true, []);
        }
        if (attachmentUrls.length > 0) {
            appendMessage('user', '', true, attachmentUrls);
        }

        clearAttachments();

        if (attachmentUrls.length > 0) {
            const hasImages = attachmentUrls.some(att => supportedImageExtensions.includes(att.name.split('.').pop().toLowerCase()));
            if (hasImages) {
                await sendMultipleFiles(attachmentUrls, message);
            } else {
                for (const attachment of attachmentUrls) {
                    if (!validateFileExtension({ name: attachment.name })) {
                        appendMessage('assistant', `Error: file "${attachment.name.split('.').pop()}" is not supported.`, true, [], true);
                        continue;
                    }
                    await sendFile(attachment, message);
                }
            }
        } else {
            await sendTextMessage(message);
        }
    }

    // Отправка текстового сообщения
    async function sendTextMessage(message) {
        let timerInterval;
        let elapsedSeconds = 0;
        const indicator = thinkActive ? thinkingIndicator : processingIndicator;
        chatMessages.appendChild(indicator);
        indicator.classList.add('active');

        if (thinkActive) {
            elapsedSeconds = 1;
            thinkingIndicator.querySelector('.thinking-time').textContent = `Thinking... ${elapsedSeconds}s`;
            timerInterval = setInterval(() => {
                elapsedSeconds++;
                thinkingIndicator.querySelector('.thinking-time').textContent = `Thinking... ${elapsedSeconds}s`;
            }, 1000);
        }

        scrollToBottomIfNeeded();

        // Обновляем список чатов после отправки запроса на генерацию изображений
        await loadChatHistory();

        isStreaming = true;
        stopStream = false;
        abortController = new AbortController();
        updateSendButton();
        
        // Обновляем список чатов после отправки запроса DeepSearch
        await loadChatHistory();
        
        // Обновляем список чатов после отправки сообщения
        await loadChatHistory();

        try {
            const model = thinkActive ? thinkModel : selectedModel.dataset.model;
            const response = await fetch('/veronica', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: message,
                    chat_id: currentChatId,
                    model: model,
                }),
                signal: abortController.signal
            });

            if (response.status === 429) {
                const errorData = await response.json();
                appendMessage('assistant', errorData.response, true, [], true);
                return;
            }

            if (!response.ok) {
                throw new Error(`Network response was not ok: ${response.status}`);
            }

            const data = await response.json();
            if (!data.response) {
                throw new Error('No response content received from server');
            }

            let finalMessage = data.response;
            // Добавляем информацию о времени обработки только для режима Think
            if (thinkActive) {
                finalMessage += `\n\n(Processed in ${elapsedSeconds} seconds)`;
            }

            if (!stopStream) {
                appendMessage('assistant', finalMessage, false);
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                // Сообщение уже добавлено в обработчике sendButton
            } else {
                console.error('Error sending message:', error);
                appendMessage('assistant', `Error sending message: ${error.message}`, true, [], true);
            }
        } finally {
            clearInterval(timerInterval);
            if (chatMessages.contains(indicator)) {
                indicator.classList.remove('active');
                chatMessages.removeChild(indicator);
            }
            abortController = null;
            isStreaming = false;
            // DeepSearch не использует режим think
            // thinkActive = false;
            if (!isTyping) {
                updateSendButton();
            }
            disableAutoScroll = false;
        }
    }

    // Отправка файла
    async function sendFile(attachment, query = '') {
        const isImage = supportedImageExtensions.includes(attachment.name.split('.').pop().toLowerCase());
        const model = isImage ? multimodalModel : (thinkActive ? thinkModel : selectedModel.dataset.model);

        let timerInterval;
        let elapsedSeconds = 0;
        const indicator = thinkActive ? thinkingIndicator : processingIndicator;
        chatMessages.appendChild(indicator);
        indicator.classList.add('active');

        if (thinkActive) {
            elapsedSeconds = 1;
            thinkingIndicator.querySelector('.thinking-time').textContent = `Thinking... ${elapsedSeconds}s`;
            timerInterval = setInterval(() => {
                elapsedSeconds++;
                thinkingIndicator.querySelector('.thinking-time').textContent = `Thinking... ${elapsedSeconds}s`;
            }, 1000);
        }

        scrollToBottomIfNeeded();

        isStreaming = true;
        stopStream = false;
        abortController = new AbortController();
        updateSendButton();
        
        // Обновляем список чатов после отправки файла
        await loadChatHistory();

        try {
            const response = await fetch(isImage ? '/veronica/chat-with-image' : '/veronica/chat-with-document', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    file_url: attachment.url,
                    query: query,
                    chat_id: currentChatId,
                    model: model
                }),
                signal: abortController.signal
            });

            if (response.status === 429) {
                const errorData = await response.json();
                appendMessage('assistant', errorData.response, true, [], true);
                return;
            }

            if (!response.ok) {
                throw new Error(`Network response was not ok: ${response.status}`);
            }

            const data = await response.json();
            if (!data.response) {
                throw new Error('No response content received from server');
            }

            let finalMessage = data.response;
            // Добавляем информацию о времени обработки только для режима Think
            if (thinkActive) {
                finalMessage += `\n\n(Processed in ${elapsedSeconds} seconds)`;
            }

            if (!stopStream) {
                appendMessage('assistant', finalMessage, false);
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                // Сообщение уже добавлено в обработчике sendButton
            } else {
                console.error('Error processing file:', error);
                appendMessage('assistant', `Error processing file: ${error.message}`, true, [], true);
            }
        } finally {
            clearInterval(timerInterval);
            
            // Скрываем индикатор DeepSearch
            if (chatMessages.contains(indicator)) {
                indicator.classList.remove('active');
                setTimeout(() => {
                    if (chatMessages.contains(indicator)) {
                        chatMessages.removeChild(indicator);
                    }
                }, 300);
            }
            
            abortController = null;
            isStreaming = false;
            // DeepSearch не использует режим think
            if (!isTyping) {
                updateSendButton();
            }
            disableAutoScroll = false;
        }
    }

    // Отправка нескольких файлов
    async function sendMultipleFiles(attachments, query = '') {
        let timerInterval;
        let elapsedSeconds = 0;
        const indicator = thinkActive ? thinkingIndicator : processingIndicator;
        chatMessages.appendChild(indicator);
        indicator.classList.add('active');
        
        // Обновляем список чатов после отправки нескольких файлов
        await loadChatHistory();

        if (thinkActive) {
            elapsedSeconds = 1;
            thinkingIndicator.querySelector('.thinking-time').textContent = `Thinking... ${elapsedSeconds}s`;
            timerInterval = setInterval(() => {
                elapsedSeconds++;
                thinkingIndicator.querySelector('.thinking-time').textContent = `Thinking... ${elapsedSeconds}s`;
            }, 1000);
        }

        isStreaming = true;
        stopStream = false;
        abortController = new AbortController();
        updateSendButton();

        try {
            console.log('Sending attachments:', attachments);
            const response = await fetch('/veronica/chat-with-multiple-images', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    files: attachments.map(att => ({ file_url: att.url, file_name: att.name })),
                    query: query,
                    chat_id: currentChatId,
                    model: multimodalModel
                }),
                signal: abortController.signal
            });

            if (response.status === 429) {
                const errorData = await response.json();
                appendMessage('assistant', errorData.response, true, [], true);
                return;
            }

            if (!response.ok) throw new Error(`Network response was not ok: ${response.status}`);
            const data = await response.json();
            let finalMessage = data.response || 'No response';
            if (thinkActive) finalMessage += `\n\n(Processed in ${elapsedSeconds} seconds)`;
            if (!stopStream) appendMessage('assistant', finalMessage, false);
        } catch (error) {
            if (error.name === 'AbortError') {
                // Сообщение уже добавлено в обработчике sendButton
            } else {
                console.error('Error in sendMultipleFiles:', error);
                appendMessage('assistant', `Error: ${error.message}`, true, [], true);
            }
        } finally {
            clearInterval(timerInterval);
            indicator.classList.remove('active');
            chatMessages.removeChild(indicator);
            abortController = null;
            isStreaming = false;
            thinkActive = false;
            updateSendButton();
            disableAutoScroll = false;
        }
    }

    // Добавление сообщения в чат
    function appendMessage(type, content, skipStreaming = false, attachments = [], isError = false) {
        const messageDiv = document.createElement('div');
        let messageClass = 'message ' + type;
        if (type === 'user') {
            if (attachments.length > 0) {
                const hasImages = attachments.some(att => supportedImageExtensions.includes(att.name.split('.').pop().toLowerCase()));
                messageClass += hasImages ? ' user-img' : ' user-files';
            } else if (content) {
                messageClass += ' user-text';
            }
        }
        messageDiv.className = messageClass;

        const actionsDiv = document.createElement('div');
        actionsDiv.className = type === 'user' ? 'user-message-actions' : 'assistant-message-actions';
        actionsDiv.style.opacity = '0';
        actionsDiv.style.visibility = 'hidden';
        actionsDiv.style.padding = '3px';
        actionsDiv.style.marginBottom = '3px';

        if (type === 'user' && content && attachments.length === 0) {
            actionsDiv.innerHTML = `
                <button class="user-message-action-btn" data-tooltip="Копировать">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M20 9h-9a2 2 0 00-2 2v9a2 2 0 002 2h9a2 2 0 002-2v-9a2 2 0 00-2-2z"></path>
                        <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
                    </svg>
                </button>
                <button class="user-message-action-btn" data-tooltip="Редактировать">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7"></path>
                        <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                </button>
            `;
        } else if (type === 'assistant' && !isError) {
            actionsDiv.innerHTML = `
                <button class="assistant-message-action-btn" data-tooltip="Копировать">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M20 9h-9a2 2 0 00-2 2v9a2 2 0 002 2h9a2 2 0 002-2v-9a2 2 0 00-2-2z"></path>
                        <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
                    </svg>
                </button>
                <button class="assistant-message-action-btn" data-tooltip="Регенерировать">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M23 4v6h-6"></path>
                        <path d="M20.49 15a9 9 0 11-2.12-9.36L23 10"></path>
                    </svg>
                </button>
                <button class="assistant-message-action-btn" data-tooltip="Нравится">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
                    </svg>
                </button>
                <button class="assistant-message-action-btn" data-tooltip="Требует доработки">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path d="M10 15v4a3 3 0 003 3l4-9V2H5.72a2 2 0 00-2 1.7l-1.38 9a2 2 0 002 2.3zm7-13h2.67A2.31 2.31 0 0122 4v7a2.31 2.31 0 01-2.33 2H17"></path>
                    </svg>
                </button>
            `;
        }

        messageDiv.appendChild(actionsDiv);

        const messageContent = document.createElement('div');
        messageContent.className = 'message-content';
        if (content) {
            messageContent.textContent = content;
        }
        messageDiv.appendChild(messageContent);

        const copyBtn = actionsDiv.querySelector('[data-tooltip="Копировать"]');
        const editBtn = type === 'user' && content && attachments.length === 0 ? actionsDiv.querySelector('[data-tooltip="Редактировать"]') : null;
        const regenerateBtn = type === 'assistant' && !isError ? actionsDiv.querySelector('[data-tooltip="Регенерировать"]') : null;
        const likeBtn = type === 'assistant' && !isError ? actionsDiv.querySelector('[data-tooltip="Нравится"]') : null;
        const dislikeBtn = type === 'assistant' && !isError ? actionsDiv.querySelector('[data-tooltip="Требует доработки"]') : null;

        if (copyBtn) {
            copyBtn.addEventListener('click', () => {
                const textToCopy = messageContent.textContent;
                navigator.clipboard.writeText(textToCopy).then(() => {
                    const originalTooltip = copyBtn.getAttribute('data-tooltip');
                    copyBtn.setAttribute('data-tooltip', 'Скопировано!');
                    setTimeout(() => {
                        copyBtn.setAttribute('data-tooltip', originalTooltip);
                    }, 2000);
                });
            });
        }

        if (editBtn) {
            editBtn.addEventListener('click', () => {
                messageDiv.classList.add('editing');
                const originalContent = messageContent.textContent;
                messageContent.contentEditable = true;
                messageContent.focus();

                const range = document.createRange();
                const selection = window.getSelection();
                range.selectNodeContents(messageContent);
                range.collapse(false);
                selection.removeAllRanges();
                selection.addRange(range);

                actionsDiv.style.display = 'none';

                let nextMessage = messageDiv.nextElementSibling;
                let originalAttachments = [];
                let editedAttachments = [];

                if (nextMessage && (nextMessage.classList.contains('user-img') || nextMessage.classList.contains('user-files'))) {
                    const attachmentItems = nextMessage.querySelectorAll('.message-attachment-item');
                    attachmentItems.forEach(item => {
                        const isImage = item.classList.contains('image');
                        const attachment = {
                            name: isImage ? item.querySelector('img').alt : item.querySelector('.message-attachment-name').textContent,
                            url: isImage ? item.querySelector('img').src : null,
                            isImage: isImage
                        };
                        originalAttachments.push(attachment);
                        editedAttachments.push(attachment);
                    });

                    attachmentItems.forEach((item, index) => {
                        const existingBtn = item.querySelector('.remove-attachment-btn');
                        if (existingBtn) {
                            existingBtn.remove();
                        }

                        const removeBtn = document.createElement('button');
                        removeBtn.className = 'remove-attachment-btn';
                        removeBtn.innerHTML = `
                            <svg viewBox="0 0 16 16" fill="none">
                                <path d="M3 3L13 13M3 13L13 3" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                            </svg>
                        `;
                        item.appendChild(removeBtn);

                        removeBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const attachmentName = item.querySelector('img') ? item.querySelector('img').alt : item.querySelector('.message-attachment-name').textContent;
                            editedAttachments = editedAttachments.filter(att => att.name !== attachmentName);
                            item.remove();

                            if (!nextMessage.querySelector('.message-attachment-item')) {
                                chatMessages.removeChild(nextMessage);
                                nextMessage = null;
                            }
                        });
                    });
                }

                const editActions = document.createElement('div');
                editActions.className = 'message-edit-actions';
                editActions.innerHTML = `
                    <button class="message-action-btn" data-action="save">Save</button>
                <button class="message-action-btn" data-action="cancel">Cancel</button>
                `;
                messageDiv.appendChild(editActions);

                editActions.querySelector('[data-action="save"]').addEventListener('click', () => {
                    const newContent = messageContent.textContent.trim();
                    messageContent.contentEditable = false;
                    messageDiv.classList.remove('editing');
                    messageDiv.removeChild(editActions);
                    actionsDiv.style.display = 'flex';

                    if (nextMessage && (nextMessage.classList.contains('user-img') || nextMessage.classList.contains('user-files'))) {
                        const removeButtons = nextMessage.querySelectorAll('.remove-attachment-btn');
                        removeButtons.forEach(btn => btn.remove());
                    }

                    const hasTextChanged = newContent !== originalContent;
                    const hasAttachmentsChanged = editedAttachments.length !== originalAttachments.length;

                    let assistantMessage = messageDiv.nextElementSibling;
                    if (assistantMessage && (assistantMessage.classList.contains('user-img') || assistantMessage.classList.contains('user-files'))) {
                        assistantMessage = assistantMessage.nextElementSibling;
                    }
                    if (assistantMessage && assistantMessage.classList.contains('assistant')) {
                        chatMessages.removeChild(assistantMessage);
                    }

                    messageContent.textContent = newContent;

                    if (!newContent && editedAttachments.length === 0) {
                        chatMessages.removeChild(messageDiv);
                        if (nextMessage && (nextMessage.classList.contains('user-img') || nextMessage.classList.contains('user-files'))) {
                            chatMessages.removeChild(nextMessage);
                        }
                        return;
                    }

                    if (editedAttachments.length > 0) {
                        if (nextMessage && (nextMessage.classList.contains('user-img') || nextMessage.classList.contains('user-files'))) {
                            chatMessages.removeChild(nextMessage);
                        }

                        const newAttachmentMessage = document.createElement('div');
                        newAttachmentMessage.className = `message user ${editedAttachments.some(att => att.isImage) ? 'user-img' : 'user-files'}`;
                        const attachmentList = document.createElement('div');
                        attachmentList.className = 'message-attachment-list';
                        editedAttachments.forEach(att => {
                            const attachmentItem = document.createElement('div');
                            attachmentItem.className = `message-attachment-item ${att.isImage ? 'image' : 'file'}`;
                            attachmentItem.style.width = att.isImage ? '300px' : '280px';
                            attachmentItem.style.height = att.isImage ? '300px' : '60px';
                            if (att.isImage) {
                                attachmentItem.innerHTML = `
                                    <img src="${att.url}" alt="${att.name}" style="object-fit: contain; border-radius: 10px; cursor: pointer;">
                                `;
                                attachmentItem.querySelector('img').addEventListener('click', () => {
                                    previewImage.src = att.url;
                                    imagePreviewOverlay.classList.add('active');
                                });
                            } else {
                                attachmentItem.innerHTML = `
                                    <svg class="message-attachment-icon" viewBox="0 0 24 24" fill="none">
                                        <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8l-6-6z" stroke="currentColor" stroke-width="2"/>
                                        <path d="M14 2v6h6" stroke="currentColor" stroke-width="2"/>
                                    </svg>
                                    <span class="message-attachment-name">${att.name}</span>
                                `;
                                // Добавляем обработчик клика для предпросмотра текстовых файлов
                                const extension = att.name.split('.').pop().toLowerCase();
                                if (supportedDocumentExtensions.includes(extension)) {
                                    attachmentItem.addEventListener('click', () => {
                                        openFilePreview(att.name, att.url);
                                    });
                                }
                            }
                            attachmentList.appendChild(attachmentItem);
                        });
                        newAttachmentMessage.appendChild(attachmentList);
                        chatMessages.insertBefore(newAttachmentMessage, messageDiv.nextElementSibling || null);
                        requestAnimationFrame(() => {
                            newAttachmentMessage.style.opacity = '1';
                            newAttachmentMessage.style.transform = 'translateY(0)';
                            scrollToBottomIfNeeded();
                            toggleScrollDownButton();
                        });
                    } else if (nextMessage && (nextMessage.classList.contains('user-img') || nextMessage.classList.contains('user-files'))) {
                        chatMessages.removeChild(nextMessage);
                    }

                    if (hasTextChanged || hasAttachmentsChanged) {
                        if (newContent || editedAttachments.length > 0) {
                            if (editedAttachments.length > 0) {
                                const hasImages = editedAttachments.some(att => att.isImage);
                                if (hasImages) {
                                    sendMultipleFiles(editedAttachments, newContent);
                                } else {
                                    sendFile(editedAttachments[0], newContent);
                                }
                            } else if (newContent) {
                                sendTextMessage(newContent);
                            }
                        }
                    }
                });

                editActions.querySelector('[data-action="cancel"]').addEventListener('click', () => {
                    messageContent.textContent = originalContent;
                    messageContent.contentEditable = false;
                    messageDiv.classList.remove('editing');
                    messageDiv.removeChild(editActions);
                    actionsDiv.style.display = 'flex';

                    let sibling = messageDiv.nextElementSibling;
                    while (sibling && (sibling.classList.contains('user-img') || sibling.classList.contains('user-files'))) {
                        const nextSibling = sibling.nextElementSibling;
                        chatMessages.removeChild(sibling);
                        sibling = nextSibling;
                    }

                    if (originalAttachments.length > 0) {
                        const restoredMessage = document.createElement('div');
                        restoredMessage.className = `message user ${originalAttachments.some(att => att.isImage) ? 'user-img' : 'user-files'}`;
                        const attachmentList = document.createElement('div');
                        attachmentList.className = 'message-attachment-list';
                        originalAttachments.forEach(att => {
                            const attachmentItem = document.createElement('div');
                            attachmentItem.className = `message-attachment-item ${att.isImage ? 'image' : 'file'}`;
                            attachmentItem.style.width = att.isImage ? '300px' : '280px';
                            attachmentItem.style.height = att.isImage ? '300px' : '60px';
                            if (att.isImage) {
                                attachmentItem.innerHTML = `
                                    <img src="${att.url}" alt="${att.name}" style="object-fit: contain; border-radius: 10px; cursor: pointer;">
                                `;
                                attachmentItem.querySelector('img').addEventListener('click', () => {
                                    previewImage.src = att.url;
                                    imagePreviewOverlay.classList.add('active');
                                });
                            } else {
                                attachmentItem.innerHTML = `
                                    <svg class="message-attachment-icon" viewBox="0 0 24 24" fill="none">
                                        <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8l-6-6z" stroke="currentColor" stroke-width="2"/>
                                        <path d="M14 2v6h6" stroke="currentColor" stroke-width="2"/>
                                    </svg>
                                    <span class="message-attachment-name">${att.name}</span>
                                `;
                                // Добавляем обработчик клика для предпросмотра текстовых файлов
                                const extension = att.name.split('.').pop().toLowerCase();
                                if (supportedDocumentExtensions.includes(extension)) {
                                    attachmentItem.addEventListener('click', () => {
                                        openFilePreview(att.name, att.url);
                                    });
                                }
                            }
                            attachmentList.appendChild(attachmentItem);
                        });
                        restoredMessage.appendChild(attachmentList);
                        chatMessages.insertBefore(restoredMessage, messageDiv.nextElementSibling || null);
                        requestAnimationFrame(() => {
                            restoredMessage.style.opacity = '1';
                            restoredMessage.style.transform = 'translateY(0)';
                            scrollToBottomIfNeeded();
                            toggleScrollDownButton();
                        });
                    }
                });
            });
        }

        if (regenerateBtn) {
            regenerateBtn.addEventListener('click', () => {
                const messages = Array.from(chatMessages.children);
                const currentIndex = messages.indexOf(messageDiv);
                let userMessage = '';
                let userAttachments = [];
                for (let i = currentIndex - 1; i >= 0; i--) {
                    if (messages[i].classList.contains('user')) {
                        userMessage = messages[i].querySelector('.message-content').textContent;
                        const nextMessage = messages[i].nextElementSibling;
                        if (nextMessage && (nextMessage.classList.contains('user-img') || nextMessage.classList.contains('user-files'))) {
                            const attachmentItems = nextMessage.querySelectorAll('.message-attachment-item');
                            attachmentItems.forEach(item => {
                                const isImage = item.classList.contains('image');
                                userAttachments.push({
                                    name: isImage ? item.querySelector('img').alt : item.querySelector('.message-attachment-name').textContent,
                                    url: isImage ? item.querySelector('img').src : null,
                                    isImage: isImage
                                });
                            });
                        }
                        break;
                    }
                }
                if (userMessage || userAttachments.length > 0) {
                    chatMessages.removeChild(messageDiv);
                    if (userAttachments.length > 0) {
                        const hasImages = userAttachments.some(att => att.isImage);
                        if (hasImages) {
                            sendMultipleFiles(userAttachments, userMessage);
                        } else {
                            sendFile(userAttachments[0], userMessage);
                        }
                    } else {
                        sendTextMessage(userMessage);
                    }
                }
            });
        }

        if (likeBtn) {
            likeBtn.addEventListener('click', () => {
                likeBtn.classList.toggle('active');
                if (dislikeBtn.classList.contains('active')) {
                    dislikeBtn.classList.remove('active');
                }
                if (likeBtn.classList.contains('active') || dislikeBtn.classList.contains('active')) {
                    actionsDiv.style.opacity = '1';
                    actionsDiv.style.visibility = 'visible';
                    actionsDiv.style.display = 'flex';
                } else {
                    actionsDiv.style.opacity = '0';
                    actionsDiv.style.visibility = 'hidden';
                    setTimeout(() => {
                        if (!messageDiv.matches(':hover') && !likeBtn.classList.contains('active') && !dislikeBtn.classList.contains('active')) {
                            actionsDiv.style.display = 'none';
                        }
                    }, 200);
                }
            });
        }

        if (dislikeBtn) {
            dislikeBtn.addEventListener('click', () => {
                dislikeBtn.classList.toggle('active');
                if (likeBtn.classList.contains('active')) {
                    likeBtn.classList.remove('active');
                }
                if (likeBtn.classList.contains('active') || dislikeBtn.classList.contains('active')) {
                    actionsDiv.style.opacity = '1';
                    actionsDiv.style.visibility = 'visible';
                    actionsDiv.style.display = 'flex';
                } else {
                    actionsDiv.style.opacity = '0';
                    actionsDiv.style.visibility = 'hidden';
                    setTimeout(() => {
                        if (!messageDiv.matches(':hover') && !likeBtn.classList.contains('active') && !dislikeBtn.classList.contains('active')) {
                            actionsDiv.style.display = 'none';
                        }
                    }, 200);
                }
            });
        }

        if (type === 'user' && content && attachments.length === 0) {
            const showActions = () => {
                if (!messageDiv.classList.contains('editing')) {
                    actionsDiv.style.display = 'flex';
                    requestAnimationFrame(() => {
                        actionsDiv.style.opacity = '1';
                        actionsDiv.style.visibility = 'visible';
                    });
                }
            };

            const hideActions = () => {
                if (!messageDiv.classList.contains('editing')) {
                    actionsDiv.style.opacity = '0';
                    actionsDiv.style.visibility = 'hidden';
                    setTimeout(() => {
                        if (!messageDiv.matches(':hover') && !actionsDiv.matches(':hover')) {
                            actionsDiv.style.display = 'none';
                        }
                    }, 200);
                }
            };

            messageDiv.addEventListener('mouseenter', showActions);
            messageDiv.addEventListener('mouseleave', hideActions);
            actionsDiv.addEventListener('mouseenter', showActions);
            actionsDiv.addEventListener('mouseleave', hideActions);
        }

        if (type === 'assistant' && !isError) {
            const showActions = () => {
                if (!isTyping) {
                    actionsDiv.style.display = 'flex';
                    requestAnimationFrame(() => {
                        actionsDiv.style.opacity = '1';
                        actionsDiv.style.visibility = 'visible';
                    });
                }
            };

            const hideActions = () => {
                if (!isTyping && !likeBtn.classList.contains('active') && !dislikeBtn.classList.contains('active')) {
                    actionsDiv.style.opacity = '0';
                    actionsDiv.style.visibility = 'hidden';
                    setTimeout(() => {
                        if (!messageDiv.matches(':hover') && !actionsDiv.matches(':hover')) {
                            actionsDiv.style.display = 'none';
                        }
                    }, 200);
                }
            };

            messageDiv.addEventListener('mouseenter', showActions);
            messageDiv.addEventListener('mouseleave', hideActions);
            actionsDiv.addEventListener('mouseenter', showActions);
            actionsDiv.addEventListener('mouseleave', hideActions);
        }

        if (attachments.length > 0) {
            const attachmentList = document.createElement('div');
            attachmentList.className = 'message-attachment-list';

            attachments.forEach(attachment => {
                const isImage = supportedImageExtensions.includes(attachment.name.split('.').pop().toLowerCase());
                const attachmentItem = document.createElement('div');
                attachmentItem.className = `message-attachment-item ${isImage ? 'image' : 'file'}`;
                attachmentItem.style.width = isImage ? '300px' : '280px';
                attachmentItem.style.height = isImage ? '300px' : '60px';

                if (isImage) {
                    attachmentItem.innerHTML = `
                        <div style="position: relative;">
                            <img src="${attachment.url}" alt="${attachment.name}" style="object-fit: contain; border-radius: 10px; cursor: pointer;">
                            ${type === 'assistant' ? `
                            <button class="download-image-btn" style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.5); border: none; border-radius: 5px; padding: 5px; cursor: pointer;">
                                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white">
                                    <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                            ` : ''}
                        </div>
                    `;
                    attachmentItem.querySelector('img').addEventListener('click', () => {
                        previewImage.src = attachment.url;
                        imagePreviewOverlay.classList.add('active');
                    });
                    
                    // Добавляем обработчик для кнопки скачивания
                    if (type === 'assistant') {
                        const downloadBtn = attachmentItem.querySelector('.download-image-btn');
                        if (downloadBtn) {
                            downloadBtn.addEventListener('click', (e) => {
                                e.stopPropagation(); // Предотвращаем открытие превью
                                const a = document.createElement('a');
                                a.href = attachment.url;
                                a.download = attachment.name || 'veronica-generated-image.png';
                                document.body.appendChild(a);
                                a.click();
                                document.body.removeChild(a);
                            });
                        }
                    }
                } else {
                    attachmentItem.innerHTML = `
                        <svg class="message-attachment-icon" viewBox="0 0 24 24" fill="none">
                            <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8l-6-6z" stroke="currentColor" stroke-width="2"/>
                            <path d="M14 2v6h6" stroke="currentColor" stroke-width="2"/>
                        </svg>
                        <span class="message-attachment-name">${attachment.name}</span>
                    `;
                    // Добавляем обработчик клика для предпросмотра текстовых файлов
                    const extension = attachment.name.split('.').pop().toLowerCase();
                    if (supportedDocumentExtensions.includes(extension)) {
                        attachmentItem.addEventListener('click', () => {
                            openFilePreview(attachment.name, attachment.url);
                        });
                    }
                }

                attachmentList.appendChild(attachmentItem);
            });

            messageDiv.appendChild(attachmentList);
        }

        chatMessages.appendChild(messageDiv);
        requestAnimationFrame(() => {
            messageDiv.style.opacity = '1';
            messageDiv.style.transform = 'translateY(0)';
            scrollToBottomIfNeeded();
            toggleScrollDownButton();
        });

        if (type === 'assistant' && !skipStreaming && !isError) {
            const parsedContent = marked.parse(content);
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = parsedContent;
            const plainText = tempDiv.textContent || tempDiv.innerText;
            let i = 0;
            isTyping = true;
            updateSendButton();

            function typeText() {
                if (stopStream || !isTyping) {
                    isTyping = false;
                    isStreaming = false;
                    updateSendButton();
                    if (likeBtn.classList.contains('active') || dislikeBtn.classList.contains('active')) {
                        actionsDiv.style.display = 'flex';
                        actionsDiv.style.opacity = '1';
                        actionsDiv.style.visibility = 'visible';
                    }
                    scrollToBottomIfNeeded();
                    toggleScrollDownButton();
                    return;
                }
                if (i < plainText.length) {
                    messageContent.innerHTML = parsedContent.substring(0, i);
                    i++;
                    scrollToBottomIfNeeded();
                    setTimeout(typeText, 5);
                } else {
                    messageContent.innerHTML = parsedContent;
                    isTyping = false;
                    isStreaming = false;
                    updateSendButton();
                    if (likeBtn.classList.contains('active') || dislikeBtn.classList.contains('active')) {
                        actionsDiv.style.display = 'flex';
                        actionsDiv.style.opacity = '1';
                        actionsDiv.style.visibility = 'visible';
                    }
                    scrollToBottomIfNeeded();
                    toggleScrollDownButton();
                }
            }
            typeText();
        } else if (type === 'assistant' && (skipStreaming || isError)) {
            // Применяем Markdown форматирование для сообщений, загруженных из истории
            if (!isError) {
                messageContent.innerHTML = marked.parse(content);
            }
            actionsDiv.style.display = 'flex';
            if (likeBtn && (likeBtn.classList.contains('active') || dislikeBtn.classList.contains('active'))) {
                actionsDiv.style.opacity = '1';
                actionsDiv.style.visibility = 'visible';
            }
            toggleScrollDownButton();
        } else if (type === 'user' && content && attachments.length === 0) {
            // Для сообщений пользователя не применяем Markdown форматирование,
            // так как они отображаются как обычный текст
            actionsDiv.style.display = 'flex';
            toggleScrollDownButton();
        }
    }

    // Прокрутка к нижней части чата, если нужно
    function scrollToBottomIfNeeded() {
        if (!disableAutoScroll) {
            const isAtBottom = scrollContainer.scrollHeight - scrollContainer.scrollTop <= scrollContainer.clientHeight + 50;
            if (isAtBottom) {
                scrollContainer.scrollTop = scrollContainer.scrollHeight;
            }
        }
    }

    // Переключение видимости кнопки прокрутки вниз
    function toggleScrollDownButton() {
        const scrollHeight = scrollContainer.scrollHeight;
        const scrollTop = scrollContainer.scrollTop;
        const clientHeight = scrollContainer.clientHeight;

        const isAtBottom = scrollHeight - scrollTop <= clientHeight + 50;
        const shouldShow = !isAtBottom && scrollHeight > clientHeight;

        if (shouldShow) {
            scrollDownButton.style.bottom = '180px';
            scrollDownButton.classList.add('visible');
        } else {
            scrollDownButton.style.bottom = '145px';
            scrollDownButton.classList.remove('visible');
        }
    }

    // Загрузка истории чатов
    async function loadChatHistory() {
        try {
            const response = await fetch('/veronica/chats');
            if (!response.ok) {
                throw new Error(`Failed to load chat history: ${response.status} ${response.statusText}`);
            }
            const chats = await response.json();
            
            // Очищаем список чатов
            chatList.innerHTML = '';
            
            // Добавляем стиль для скроллбара
            chatList.style.overflowY = 'auto';
            chatList.style.scrollbarWidth = 'thin';
            chatList.style.scrollbarColor = 'var(--accent-color) var(--primary-bg)';
            
            // Стили для WebKit (Chrome, Safari)
            const style = document.createElement('style');
            style.textContent = `
                #chat-list::-webkit-scrollbar {
                    width: 8px;
                }
                #chat-list::-webkit-scrollbar-track {
                    background: var(--primary-bg);
                    border-radius: 10px;
                }
                #chat-list::-webkit-scrollbar-thumb {
                    background: var(--accent-color);
                    border-radius: 10px;
                    border: 2px solid var(--primary-bg);
                }
            `;
            document.head.appendChild(style);
            
            // Добавляем чаты в список
            if (chats.length === 0) {
                // Если чатов нет, добавляем сообщение
                const emptyItem = document.createElement('div');
                emptyItem.className = 'chat-empty';
                emptyItem.textContent = 'No saved chats';
                chatList.appendChild(emptyItem);
            } else {
                // Отображаем чаты в обратном порядке, чтобы новые были сверху
                // Создаем копию массива и переворачиваем его
                const reversedChats = [...chats].reverse();
                reversedChats.forEach((chat, index) => {
                    const chatItem = document.createElement('button');
                    chatItem.className = 'chat-item';
                    chatItem.setAttribute('data-chat-id', chat.chat_id);
                    
                    // Определяем название чата
                    let chatName = `New Chat`;
                    
                    // Если есть сообщения, используем первое сообщение пользователя как название
                    if (chat.messages && chat.messages.length > 0) {
                        // Ищем первое сообщение пользователя
                        const firstUserMessage = chat.messages.find(msg => msg.role === 'user');
                        if (firstUserMessage) {
                            // Используем первые 20 символов сообщения как название
                            chatName = firstUserMessage.content.substring(0, 20);
                            if (firstUserMessage.content.length > 20) {
                                chatName += '...';
                            }
                        }
                    }
                    
                    chatItem.textContent = chatName;
                    
                    // Добавляем кнопку с троеточием для действий с чатом
                    const menuBtn = document.createElement('button');
                    menuBtn.className = 'chat-menu-btn';
                    menuBtn.innerHTML = `
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                            <circle cx="12" cy="12" r="1" stroke-width="2"/>
                            <circle cx="12" cy="5" r="1" stroke-width="2"/>
                            <circle cx="12" cy="19" r="1" stroke-width="2"/>
                        </svg>
                    `;
                    menuBtn.style.marginLeft = 'auto';
                    menuBtn.style.background = 'transparent';
                    menuBtn.style.border = '1px solid var(--border-color)';
                    menuBtn.style.color = 'var(--text-color)';
                    menuBtn.style.padding = '0.5rem';
                    menuBtn.style.borderRadius = '10px';
                    menuBtn.style.cursor = 'pointer';
                    menuBtn.style.transition = 'color 0.3s ease, border-color 0.3s ease';
                    
                    menuBtn.addEventListener('mouseover', () => {
                        menuBtn.style.color = 'var(--accent-color)';
                        menuBtn.style.borderColor = 'var(--accent-color)';
                    });
                    
                    menuBtn.addEventListener('mouseout', () => {
                        menuBtn.style.color = 'var(--text-color)';
                        menuBtn.style.borderColor = 'var(--border-color)';
                    });
                    
                    chatItem.style.display = 'flex';
                    chatItem.style.alignItems = 'center';
                    chatItem.style.justifyContent = 'space-between';
                    
                    // Добавляем обработчик для выделения выбранного чата
                    chatItem.addEventListener('click', function() {
                        // Удаляем выделение со всех чатов
                        const allChatItems = document.querySelectorAll('.chat-item');
                        allChatItems.forEach(item => {
                            item.style.backgroundColor = 'transparent';
                        });
                        
                        // Выделяем текущий чат
                        this.style.backgroundColor = 'var(--hover-color)';
                    });
                    chatItem.appendChild(menuBtn);
                    
                    // Обработчик для кнопки меню
                    menuBtn.addEventListener('click', async (e) => {
                        e.stopPropagation(); // Предотвращаем всплытие события
                        
                        // Проверяем, есть ли уже открытое меню
                        const existingMenu = document.querySelector('.chat-menu');
                        if (existingMenu) {
                            document.body.removeChild(existingMenu);
                            return; // Выходим из функции, чтобы при повторном нажатии меню исчезало
                        }
                        
                        // Создаем меню
                        const menu = document.createElement('div');
                        menu.className = 'chat-menu';
                        
                        // Позиционируем меню рядом с кнопкой
                        const rect = menuBtn.getBoundingClientRect();
                        menu.style.position = 'fixed';
                        menu.style.top = `${rect.top}px`;
                        
                        // Проверяем ширину экрана для мобильных устройств
                        if (window.innerWidth <= 768) {
                            // Для мобильных устройств показываем меню слева от кнопки
                            menu.style.left = `${rect.left - menu.offsetWidth - 5}px`;
                        } else {
                            // Для десктопов показываем меню справа от кнопки
                            menu.style.left = `${rect.right + 5}px`;
                        }
                        menu.style.zIndex = '1001';
                        menu.style.background = 'var(--primary-bg)';
                        menu.style.border = '1px solid var(--border-color)';
                        menu.style.borderRadius = '8px';
                        menu.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
                        
                        // Добавляем пункты меню
                        const menuItems = [
                            {
                                icon: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                    <path d="M12 5v14M5 12h14" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>`,
                                text: 'Rename',
                                action: () => {
                                    // Закрываем меню
                                    document.body.removeChild(menu);
                                    
                                    // Получаем текущее имя чата
                                    const currentName = chatItem.textContent.trim();
                                    
                                    // Очищаем содержимое элемента чата
                                    chatItem.innerHTML = '';
                                    
                                    // Создаем поле ввода
                                    const input = document.createElement('input');
                                    input.type = 'text';
                                    input.value = currentName;
                                    input.className = 'chat-rename-input';
                                    input.style.flex = '1';
                                    input.style.border = '1px solid var(--border-color)';
                                    input.style.borderRadius = '5px';
                                    input.style.padding = '5px';
                                    input.style.background = 'var(--primary-bg)';
                                    input.style.color = 'var(--text-color)';
                                    
                                    // Создаем кнопки действий
                                    const buttonsContainer = document.createElement('div');
                                    buttonsContainer.style.display = 'flex';
                                    buttonsContainer.style.gap = '5px';
                                    buttonsContainer.style.marginTop = '10px'; // Изменено с marginLeft на marginTop
                                    buttonsContainer.style.justifyContent = 'center'; // Центрируем кнопки
                                    
                                    const cancelBtn = document.createElement('button');
                                    cancelBtn.textContent = 'Cancel';
                                    cancelBtn.className = 'action-btn';
                                    cancelBtn.style.padding = '3px 8px';
                                    cancelBtn.style.fontSize = '12px';
                                    
                                    const saveBtn = document.createElement('button');
                                    saveBtn.textContent = 'Save';
                                    saveBtn.className = 'action-btn';
                                    saveBtn.style.padding = '3px 8px';
                                    saveBtn.style.fontSize = '12px';
                                    
                                    buttonsContainer.appendChild(cancelBtn);
                                    buttonsContainer.appendChild(saveBtn);
                                    
                                    // Создаем контейнер для вертикального расположения элементов
                                    const container = document.createElement('div');
                                    container.style.display = 'flex';
                                    container.style.flexDirection = 'column';
                                    container.style.width = '100%';
                                    
                                    // Добавляем элементы в контейнер
                                    container.appendChild(input);
                                    container.appendChild(buttonsContainer);
                                    
                                    // Устанавливаем стили для контейнера, чтобы кнопки были внизу
                                    container.style.display = 'flex';
                                    container.style.flexDirection = 'column';
                                    container.style.justifyContent = 'space-between';
                                    container.style.height = '100%';
                                    container.style.minHeight = '60px';
                                    
                                    // Добавляем контейнер в чат
                                    chatItem.appendChild(container);
                                    
                                    // Фокусируемся на поле ввода
                                    input.focus();
                                    
                                    // Обработчик для кнопки отмены
                                    cancelBtn.addEventListener('click', (e) => {
                                        e.stopPropagation();
                                        restoreChatItem();
                                        
                                        // Добавляем небольшую задержку перед восстановлением функциональности кнопки
                                        setTimeout(() => {
                                            const newMenuBtn = chatItem.querySelector('.chat-menu-btn');
                                            if (newMenuBtn) {
                                                newMenuBtn.style.pointerEvents = 'auto';
                                                // Обработчик клика уже добавлен в функции restoreChatItem
                                            }
                                        }, 100);
                                    });
                                    
                                    // Обработчик для кнопки сохранения
                                    saveBtn.addEventListener('click', async (e) => {
                                        e.stopPropagation();
                                        const newName = input.value.trim();
                                        if (newName) {
                                            try {
                                                // Здесь можно добавить запрос к API для сохранения нового имени
                                                // Пока просто обновляем интерфейс
                                                restoreChatItem(newName);
                                            } catch (error) {
                                                console.error('Error renaming chat:', error);
                                                showNotification(`Error renaming chat: ${error.message}`);
                                                restoreChatItem();
                                            }
                                        } else {
                                            restoreChatItem();
                                        }
                                    });
                                    
                                    // Обработчик для клавиши Enter
                                    input.addEventListener('keydown', (e) => {
                                        if (e.key === 'Enter') {
                                            saveBtn.click();
                                        } else if (e.key === 'Escape') {
                                            cancelBtn.click();
                                        }
                                    });
                                    
                                    // Функция для восстановления элемента чата
                                    function restoreChatItem(newName = null) {
                                        chatItem.innerHTML = '';
                                        chatItem.textContent = newName || currentName;
                                        
                                        // Добавляем кнопку с троеточием обратно
                                        const menuBtn = document.createElement('button');
                                        menuBtn.className = 'chat-menu-btn';
                                        menuBtn.innerHTML = `
                                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                <circle cx="12" cy="12" r="1" stroke-width="2"/>
                                                <circle cx="12" cy="5" r="1" stroke-width="2"/>
                                                <circle cx="12" cy="19" r="1" stroke-width="2"/>
                                            </svg>
                                        `;
                                        menuBtn.style.marginLeft = 'auto';
                                        menuBtn.style.background = 'transparent';
                                        menuBtn.style.border = '1px solid var(--border-color)';
                                        menuBtn.style.color = 'var(--text-color)';
                                        menuBtn.style.padding = '0.5rem';
                                        menuBtn.style.borderRadius = '10px';
                                        menuBtn.style.cursor = 'pointer';
                                        menuBtn.style.transition = 'color 0.3s ease, border-color 0.3s ease';
                                        
                                        menuBtn.addEventListener('mouseover', () => {
                                            menuBtn.style.color = 'var(--accent-color)';
                                            menuBtn.style.borderColor = 'var(--accent-color)';
                                        });
                                        
                                        menuBtn.addEventListener('mouseout', () => {
                                            menuBtn.style.color = 'var(--text-color)';
                                            menuBtn.style.borderColor = 'var(--border-color)';
                                        });
                                        
                                        chatItem.style.display = 'flex';
                                        chatItem.style.alignItems = 'center';
                                        chatItem.style.justifyContent = 'space-between';
                                        chatItem.appendChild(menuBtn);
                                        
                                        // Восстанавливаем возможность нажатия на кнопку меню
                                        menuBtn.style.pointerEvents = 'auto';
                                        
                                        // Добавляем обработчик клика для кнопки меню
                                        menuBtn.addEventListener('click', async (e) => {
                                            e.stopPropagation(); // Предотвращаем всплытие события
                                            
                                            // Проверяем, есть ли уже открытое меню
                                            const existingMenu = document.querySelector('.chat-menu');
                                            if (existingMenu) {
                                                document.body.removeChild(existingMenu);
                                                return; // Выходим из функции, чтобы при повторном нажатии меню исчезало
                                            }
                                            
                                            // Создаем меню
                                            const menu = document.createElement('div');
                                            menu.className = 'chat-menu';
                                            
                                            // Позиционируем меню рядом с кнопкой
                                            const rect = menuBtn.getBoundingClientRect();
                                            menu.style.position = 'fixed';
                                            menu.style.top = `${rect.top}px`;
                                            
                                            // Проверяем ширину экрана для мобильных устройств
                                            if (window.innerWidth <= 768) {
                                                // Для мобильных устройств показываем меню слева от кнопки
                                                menu.style.left = `${rect.left - menu.offsetWidth - 5}px`;
                                            } else {
                                                // Для десктопов показываем меню справа от кнопки
                                                menu.style.left = `${rect.right + 5}px`;
                                            }
                                            menu.style.zIndex = '1001';
                                            menu.style.background = 'var(--primary-bg)';
                                            menu.style.border = '1px solid var(--border-color)';
                                            menu.style.borderRadius = '8px';
                                            menu.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
                                            
                                            // Добавляем пункты меню
                                            const menuItems = [
                                                {
                                                    icon: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                        <path d="M12 5v14M5 12h14" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                                    </svg>`,
                                                    text: 'Rename',
                                                    action: () => {
                                                        // Закрываем меню
                                                        document.body.removeChild(menu);
                                                        
                                                        // Получаем текущее имя чата
                                                        const currentName = chatItem.textContent.trim();
                                                        
                                                        // Очищаем содержимое элемента чата
                                                        chatItem.innerHTML = '';
                                                        
                                                        // Создаем поле ввода
                                                        const input = document.createElement('input');
                                                        input.type = 'text';
                                                        input.value = currentName;
                                                        input.className = 'chat-rename-input';
                                                        input.style.flex = '1';
                                                        input.style.border = '1px solid var(--border-color)';
                                                        input.style.borderRadius = '5px';
                                                        input.style.padding = '5px';
                                                        input.style.background = 'var(--primary-bg)';
                                                        input.style.color = 'var(--text-color)';
                                                        
                                                        // Создаем кнопки действий
                                                        const buttonsContainer = document.createElement('div');
                                                        buttonsContainer.style.display = 'flex';
                                                        buttonsContainer.style.gap = '5px';
                                                        buttonsContainer.style.marginTop = '10px';
                                                        buttonsContainer.style.justifyContent = 'center';
                                                        
                                                        const cancelBtn = document.createElement('button');
                                                        cancelBtn.textContent = 'Cancel';
                                                        cancelBtn.className = 'action-btn';
                                                        cancelBtn.style.padding = '3px 8px';
                                                        cancelBtn.style.fontSize = '12px';
                                                        
                                                        const saveBtn = document.createElement('button');
                                                        saveBtn.textContent = 'Save';
                                                        saveBtn.className = 'action-btn';
                                                        saveBtn.style.padding = '3px 8px';
                                                        saveBtn.style.fontSize = '12px';
                                                        
                                                        buttonsContainer.appendChild(cancelBtn);
                                                        buttonsContainer.appendChild(saveBtn);
                                                        
                                                        // Создаем контейнер для вертикального расположения элементов
                                                        const container = document.createElement('div');
                                                        container.style.display = 'flex';
                                                        container.style.flexDirection = 'column';
                                                        container.style.width = '100%';
                                                        
                                                        // Добавляем элементы в контейнер
                                                        container.appendChild(input);
                                                        container.appendChild(buttonsContainer);
                                                        
                                                        // Устанавливаем стили для контейнера, чтобы кнопки были внизу
                                                        container.style.display = 'flex';
                                                        container.style.flexDirection = 'column';
                                                        container.style.justifyContent = 'space-between';
                                                        container.style.height = '100%';
                                                        container.style.minHeight = '60px';
                                                        
                                                        // Добавляем контейнер в чат
                                                        chatItem.appendChild(container);
                                                        
                                                        // Фокусируемся на поле ввода
                                                        input.focus();
                                                        
                                                        // Обработчик для кнопки отмены
                                                        cancelBtn.addEventListener('click', (e) => {
                                                            e.stopPropagation();
                                                            restoreChatItem();
                                                        });
                                                        
                                                        // Обработчик для кнопки сохранения
                                                        saveBtn.addEventListener('click', async (e) => {
                                                            e.stopPropagation();
                                                            const newName = input.value.trim();
                                                            if (newName) {
                                                                try {
                                                                    // Здесь можно добавить запрос к API для сохранения нового имени
                                                                    // Пока просто обновляем интерфейс
                                                                    restoreChatItem(newName);
                                                                } catch (error) {
                                                                    console.error('Error renaming chat:', error);
                                                                    showNotification(`Error renaming chat: ${error.message}`);
                                                                    restoreChatItem();
                                                                }
                                                            } else {
                                                                restoreChatItem();
                                                            }
                                                        });
                                                        
                                                        // Обработчик для клавиши Enter
                                                        input.addEventListener('keydown', (e) => {
                                                            if (e.key === 'Enter') {
                                                                saveBtn.click();
                                                            } else if (e.key === 'Escape') {
                                                                cancelBtn.click();
                                                            }
                                                        });
                                                    }
                                                },
                                                {
                                                    icon: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                        <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                                    </svg>`,
                                                    text: 'Delete',
                                                    action: async () => {
                                                        try {
                                                            const chatId = chat.chat_id;
                                                            const response = await fetch(`/veronica/chat/${chatId}`, {
                                                                method: 'DELETE'
                                                            });
                                                            
                                                            if (!response.ok) {
                                                                throw new Error(`Failed to delete chat: ${response.status} ${response.statusText}`);
                                                            }
                                                            
                                                            // Удаляем элемент из списка
                                                            chatList.removeChild(chatItem);
                                                            
                                                            // Если это был текущий чат, создаем новый
                                                            if (currentChatId === chatId) {
                                                                createNewChat();
                                                            }
                                                            
                                                            // Если список пуст, показываем сообщение
                                                            if (chatList.children.length === 0) {
                                                                const emptyItem = document.createElement('div');
                                                                emptyItem.className = 'chat-empty';
                                                                emptyItem.textContent = 'Нет сохраненных чатов';
                                                                chatList.appendChild(emptyItem);
                                                            }
                                                        } catch (error) {
                                                            console.error('Error deleting chat:', error);
                                                            showNotification(`Ошибка при удалении чата: ${error.message}`);
                                                        }
                                                        document.body.removeChild(menu);
                                                    }
                                                },
                                                {
                                                    icon: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                        <path d="M4 12v8a2 2 0 002 2h12a2 2 0 002-2v-8M16 6l-4-4-4 4M12 2v13" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                                    </svg>`,
                                                    text: 'Share',
                                                    action: () => {
                                                        showNotification('Coming soon!');
                                                        document.body.removeChild(menu);
                                                    }
                                                }
                                            ];
                                            
                                            menuItems.forEach(item => {
                                                const menuItem = document.createElement('div');
                                                menuItem.className = 'chat-menu-item';
                                                menuItem.style.display = 'flex';
                                                menuItem.style.alignItems = 'center';
                                                menuItem.style.padding = '8px 12px';
                                                menuItem.style.cursor = 'pointer';
                                                menuItem.style.transition = 'all 0.2s';
                                                
                                                menuItem.innerHTML = `
                                                    <span class="menu-icon" style="margin-right: 8px">${item.icon}</span>
                                                    <span>${item.text}</span>
                                                `;
                                                
                                                // Применяем красный цвет для кнопки Delete
                                                if (item.text === 'Delete') {
                                                    menuItem.addEventListener('mouseover', () => {
                                                        menuItem.style.background = '#ff4d4f';
                                                        menuItem.style.color = 'white';
                                                    });
                                                    
                                                    menuItem.addEventListener('mouseout', () => {
                                                        menuItem.style.background = 'transparent';
                                                        menuItem.style.color = '';
                                                    });
                                                } else {
                                                    // Для остальных кнопок используем фиолетовый hover
                                                    menuItem.addEventListener('mouseover', () => {
                                                        menuItem.style.background = 'var(--accent-color)';
                                                        menuItem.style.color = 'white';
                                                    });
                                                    
                                                    menuItem.addEventListener('mouseout', () => {
                                                        menuItem.style.background = 'transparent';
                                                        menuItem.style.color = '';
                                                    });
                                                }
                                                
                                                menuItem.addEventListener('click', item.action);
                                                
                                                menu.appendChild(menuItem);
                                            });
                                            
                                            document.body.appendChild(menu);
                                            
                                            // Закрываем меню при клике вне его
                                            const closeMenu = (e) => {
                                                if (!menu.contains(e.target) && e.target !== menuBtn) {
                                                    document.body.removeChild(menu);
                                                    document.removeEventListener('click', closeMenu);
                                                }
                                            };
                                            
                                            // Добавляем обработчик с небольшой задержкой, чтобы избежать срабатывания при создании
                                            setTimeout(() => {
                                                document.addEventListener('click', closeMenu);
                                            }, 100);
                                        });
                                    }
                                }
                            },
                            {
                                icon: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                    <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>`,
                                text: 'Delete',
                                action: async () => {
                                    try {
                                        const chatId = chat.chat_id;
                                        const response = await fetch(`/veronica/chat/${chatId}`, {
                                            method: 'DELETE'
                                        });
                                        
                                        if (!response.ok) {
                                            throw new Error(`Failed to delete chat: ${response.status} ${response.statusText}`);
                                        }
                                        
                                        // Удаляем элемент из списка
                                        chatList.removeChild(chatItem);
                                        
                                        // Если это был текущий чат, создаем новый
                                        if (currentChatId === chatId) {
                                            createNewChat();
                                        }
                                        
                                        // Если список пуст, показываем сообщение
                                        if (chatList.children.length === 0) {
                                            const emptyItem = document.createElement('div');
                                            emptyItem.className = 'chat-empty';
                                            emptyItem.textContent = 'Нет сохраненных чатов';
                                            chatList.appendChild(emptyItem);
                                        }
                                    } catch (error) {
                                        console.error('Error deleting chat:', error);
                                        showNotification(`Ошибка при удалении чата: ${error.message}`);
                                    }
                                    document.body.removeChild(menu);
                                }
                            },
                            {
                                icon: `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                    <path d="M4 12v8a2 2 0 002 2h12a2 2 0 002-2v-8M16 6l-4-4-4 4M12 2v13" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>`,
                                text: 'Share',
                                action: () => {
                                    showNotification('Coming soon!');
                                    document.body.removeChild(menu);
                                }
                            }
                        ];
                        
                        menuItems.forEach(item => {
                            const menuItem = document.createElement('div');
                            menuItem.className = 'chat-menu-item';
                            menuItem.style.display = 'flex';
                            menuItem.style.alignItems = 'center';
                            menuItem.style.padding = '8px 12px';
                            menuItem.style.cursor = 'pointer';
                            menuItem.style.transition = 'background 0.2s';
                            
                            menuItem.innerHTML = `
                                <span class="menu-icon" style="margin-right: 8px">${item.icon}</span>
                                <span>${item.text}</span>
                            `;
                            
                            menuItem.addEventListener('mouseover', () => {
                                menuItem.style.background = 'var(--hover-color)';
                            });
                            
                            menuItem.addEventListener('mouseout', () => {
                                menuItem.style.background = 'transparent';
                            });
                            
                            menuItem.addEventListener('click', item.action);
                            
                            menu.appendChild(menuItem);
                        });
                        
                        document.body.appendChild(menu);
                        
                        // Закрываем меню при клике вне его
                        const closeMenu = (e) => {
                            if (!menu.contains(e.target) && e.target !== menuBtn) {
                                document.body.removeChild(menu);
                                document.removeEventListener('click', closeMenu);
                            }
                        };
                        
                        // Добавляем обработчик с небольшой задержкой, чтобы избежать срабатывания при создании
                        setTimeout(() => {
                            document.addEventListener('click', closeMenu);
                        }, 100);
                    }
                );
                
                // Функция для добавления обработчика клика на кнопку меню
                function addMenuButtonClickHandler(menuBtn) {
                    menuBtn.addEventListener('click', async (e) => {
                        e.stopPropagation(); // Предотвращаем всплытие события
                        
                        // Проверяем, есть ли уже открытое меню
                        const existingMenu = document.querySelector('.chat-menu');
                        if (existingMenu) {
                            document.body.removeChild(existingMenu);
                            return; // Выходим из функции, чтобы при повторном нажатии меню исчезало
                        }
                        
                        // Создаем меню
                        const menu = document.createElement('div');
                        menu.className = 'chat-menu';
                        
                        // Позиционируем меню рядом с кнопкой
                        const rect = menuBtn.getBoundingClientRect();
                        menu.style.position = 'fixed';
                        menu.style.top = `${rect.top}px`;
                        
                        // Проверяем ширину экрана для мобильных устройств
                        if (window.innerWidth <= 768) {
                            // Для мобильных устройств показываем меню слева от кнопки
                            menu.style.left = `${rect.left - menu.offsetWidth - 5}px`;
                        } else {
                            // Для десктопов показываем меню справа от кнопки
                            menu.style.left = `${rect.right + 5}px`;
                        }
                        menu.style.zIndex = '1001';
                        menu.style.background = 'var(--primary-bg)';
                        menu.style.border = '1px solid var(--border-color)';
                        menu.style.borderRadius = '8px';
                        menu.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
                        
                        // Закрываем меню при клике вне его
                        const closeMenu = (e) => {
                            if (!menu.contains(e.target) && e.target !== menuBtn) {
                                document.body.removeChild(menu);
                                document.removeEventListener('click', closeMenu);
                            }
                        };
                        
                        // Добавляем обработчик с небольшой задержкой, чтобы избежать срабатывания при создании
                        setTimeout(() => {
                            document.addEventListener('click', closeMenu);
                        }, 100);
                    });
                }
                
                // Обработчик для выбора чата
                    chatItem.addEventListener('click', () => {
                        loadChat(chat.chat_id);
                        
                        // Визуальное выделение выбранного чата
                        const allChatItems = document.querySelectorAll('.chat-item');
                        allChatItems.forEach(item => {
                            item.style.backgroundColor = 'transparent';
                        });
                        chatItem.style.backgroundColor = 'var(--hover-color)';
                    });
                    
                    chatList.appendChild(chatItem);
                });
                
                // Выделяем текущий чат, если он есть в списке
                if (currentChatId) {
                    const currentChatItem = chatList.querySelector(`[data-chat-id="${currentChatId}"]`);
                    if (currentChatItem) {
                        currentChatItem.classList.add('active');
                        currentChatItem.style.backgroundColor = 'var(--hover-color)';
                    }
                }
            }
        } catch (error) {
            console.error('Error loading chat history:', error);
            // В случае ошибки показываем уведомление
            showNotification(`Ошибка при загрузке истории чатов: ${error.message}`);
            // И добавляем кнопку для повторной попытки
            chatList.innerHTML = `
                <div class="chat-error">
                    <span>Ошибка загрузки</span>
                    <button class="retry-btn">Повторить</button>
                </div>
            `;
            chatList.querySelector('.retry-btn').addEventListener('click', loadChatHistory);
        }
        
        toggleScrollDownButton();
    }

    // Загрузка конкретного чата
    async function loadChat(chatId) {
        if (currentChatId === chatId) return; // Если чат уже загружен, ничего не делаем
        
        try {
            // Проверяем, пустой ли текущий чат перед переключением
            if (currentChatId) {
                const checkResponse = await fetch(`/veronica/chat/${currentChatId}`);
                if (checkResponse.ok) {
                    const currentChatData = await checkResponse.json();
                    // Если чат пустой (нет сообщений), удаляем его
                    if (!currentChatData.messages || currentChatData.messages.length === 0) {
                        // Удаляем пустой чат
                        await fetch(`/veronica/chat/${currentChatId}`, {
                            method: 'DELETE'
                        });
                        // Обновляем список чатов после удаления
                        await loadChatHistory();
                    }
                }
            }
            // Очищаем текущие сообщения
            chatMessages.innerHTML = '';
            
            // Показываем индикатор загрузки
            const loadingIndicator = document.createElement('div');
            loadingIndicator.className = 'loading-indicator';
            loadingIndicator.innerHTML = `
                <div class="spinner"></div>
                <div class="loading-text">Загрузка сообщений...</div>
            `;
            chatMessages.appendChild(loadingIndicator);
            
            // Получаем историю чата с сервера
            const response = await fetch(`/veronica/chat/${chatId}`);
            if (!response.ok) {
                throw new Error(`Failed to load chat: ${response.status} ${response.statusText}`);
            }
            
            const chatData = await response.json();
            
            // Удаляем индикатор загрузки
            chatMessages.removeChild(loadingIndicator);
            
            // Обновляем текущий ID чата
            currentChatId = chatId;
            
            // Устанавливаем флаг isFirstMessage в false, чтобы избежать создания нового чата при отправке сообщения
            isFirstMessage = false;
            
            // Выделяем активный чат в списке
            const chatItems = chatList.querySelectorAll('.chat-item');
            chatItems.forEach(item => {
                item.classList.remove('active');
                item.style.backgroundColor = 'transparent';
            });
            const currentChatItem = chatList.querySelector(`[data-chat-id="${chatId}"]`);
            if (currentChatItem) {
                currentChatItem.classList.add('active');
                currentChatItem.style.backgroundColor = 'var(--hover-color)';
            }
            
            // Скрываем приветствие
            greeting.classList.remove('visible');
            greeting.classList.add('hidden');
            
            // Отображаем сообщения
            if (chatData.messages && chatData.messages.length > 0) {
                chatData.messages.forEach(msg => {
                    // Определяем тип сообщения (user или assistant)
                    const type = msg.role === 'user' ? 'user' : 'assistant';
                    
                    // Проверяем, содержит ли сообщение вложения
                    const attachments = [];
                    let content = msg.content;
                    
                    // Проверяем, есть ли в сообщении упоминания о загруженных файлах
                    const isFileMessage = content.includes('Документ загружен:') || 
                                         content.includes('Изображение загружено:') || 
                                         content.includes('DeepSearch:') || 
                                         content.includes('Сгенерировать изображение:');
                    
                    // Добавляем сообщение в чат
                    appendMessage(type, content, true, attachments, false);
                });
            }
            
            // Прокручиваем к последнему сообщению
            scrollContainer.scrollTo({
                top: scrollContainer.scrollHeight,
                behavior: 'smooth'
            });
            
        } catch (error) {
            console.error('Error loading chat:', error);
            showNotification(`Ошибка при загрузке чата: ${error.message}`);
            
            // В случае ошибки создаем новый чат
            createNewChat();
        }
    }
    
    // Обработчики событий
    scrollDownButton.addEventListener('click', () => {
        scrollContainer.scrollTo({
            top: scrollContainer.scrollHeight,
            behavior: 'smooth'
        });
    });
    
    // Функция для создания нового чата
    async function createNewChat() {
        try {
            // Проверяем, пустой ли текущий чат
            if (currentChatId) {
                const response = await fetch(`/veronica/chat/${currentChatId}`);
                if (response.ok) {
                    const chat = await response.json();
                    // Если в текущем чате нет сообщений, не создаем новый чат
                    if (chat.messages.length === 0) {
                        showNotification('Текущий чат пустой. Используйте его вместо создания нового.');
                        return;
                    }
                }
            }
            
            // Очищаем текущие сообщения
            chatMessages.innerHTML = '';
            
            // Создаем новый чат на сервере
            const newChatId = await createChatWithRetry();
            currentChatId = newChatId;
            
            // Устанавливаем флаг isFirstMessage в false, чтобы избежать создания нового чата при отправке сообщения
            isFirstMessage = false;
            
            // Обновляем список чатов
            await loadChatHistory();
            
            // Показываем приветствие
            greeting.classList.remove('hidden');
            greeting.classList.add('visible');
            
            // Очищаем поле ввода и вложения
            messageInput.value = '';
            clearAttachments();
            updateSendButton();
            
        } catch (error) {
            console.error('Error creating new chat:', error);
            showNotification(`Ошибка при создании нового чата: ${error.message}`);
        }
    }

    scrollContainer.addEventListener('scroll', () => {
        toggleScrollDownButton();
        const scrollHeight = scrollContainer.scrollHeight;
        const scrollTop = scrollContainer.scrollTop;
        const clientHeight = scrollContainer.clientHeight;
        const isScrollingUp = scrollTop < (scrollHeight - clientHeight - 50) && (isTyping || isStreaming);
        if (isScrollingUp && !disableAutoScroll) {
            disableAutoScroll = true;
        } else if (scrollTop + clientHeight >= scrollHeight - 50) {
            disableAutoScroll = false;
        }
    });

    window.addEventListener('resize', toggleScrollDownButton);

    sendButton.addEventListener('click', () => {
        if (isStreaming || isTyping) {
            stopStream = true;
            if (abortController) {
                abortController.abort();
                abortController = null;
            }
            if (isTyping) {
                isTyping = false;
                updateSendButton();
            }
            isStreaming = false;
            thinkActive = false;
            const indicator = thinkActive ? thinkingIndicator : processingIndicator;
            if (chatMessages.contains(indicator)) {
                indicator.classList.remove('active');
                chatMessages.removeChild(indicator);
            }
            appendMessage('assistant', '(Операция приостановлена)', true, [], true);
            scrollContainer.scrollTop = scrollContainer.scrollHeight;
            updateSendButton();
        } else if ((messageInput.value.trim() || attachedFiles.length > 0) && ongoingUploads === 0) {
            if (deepSearchActive) {
                // Если активирован режим DeepSearch, отправляем запрос DeepSearch
                const query = messageInput.value.trim();
                if (query) {
                    sendDeepSearchQuery(query);
                    // Очищаем поле ввода
                    messageInput.value = '';
                    messageInput.style.height = 'auto';
                    updateSendButton();
                    // Сбрасываем флаг DeepSearch и визуальную индикацию
                    deepSearchActive = false;
                    deepsearchBtn.classList.remove('active');
                }
            } else if (imageGenActive) {
                // Если активирован режим генерации изображений, отправляем запрос на генерацию
                const prompt = messageInput.value.trim();
                if (prompt) {
                    sendImageGenerationQuery(prompt);
                    // Очищаем поле ввода
                    messageInput.value = '';
                    messageInput.style.height = 'auto';
                    updateSendButton();
                    // Не сбрасываем флаг генерации изображений и визуальную индикацию,
                    // чтобы режим оставался активным до тех пор, пока пользователь сам его не отключит
                    // imageGenActive = false;
                    // imageGenBtn.classList.remove('active');
                }
            } else {
                // Иначе отправляем обычное сообщение
                sendMessage();
            }
        }
    });

    messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey && !isStreaming && ongoingUploads === 0) {
            e.preventDefault();
            if (deepSearchActive) {
                // Если активирован режим DeepSearch, отправляем запрос DeepSearch
                const query = messageInput.value.trim();
                if (query) {
                    sendDeepSearchQuery(query);
                    // Очищаем поле ввода
                    messageInput.value = '';
                    messageInput.style.height = 'auto';
                    updateSendButton();
                    // Сбрасываем флаг DeepSearch и визуальную индикацию
                    deepSearchActive = false;
                    deepsearchBtn.classList.remove('active');
                }
            } else if (imageGenActive) {
                // Если активирован режим генерации изображений, отправляем запрос на генерацию
                const prompt = messageInput.value.trim();
                if (prompt) {
                    sendImageGenerationQuery(prompt);
                    // Очищаем поле ввода
                    messageInput.value = '';
                    messageInput.style.height = 'auto';
                    updateSendButton();
                    // Не сбрасываем флаг генерации изображений и визуальную индикацию,
                    // чтобы режим оставался активным до тех пор, пока пользователь сам его не отключит
                    // imageGenActive = false;
                    // imageGenBtn.classList.remove('active');
                }
            } else {
                // Иначе отправляем обычное сообщение
                sendMessage();
            }
        }
    });

    messageInput.addEventListener('paste', (e) => {
        e.preventDefault();
        const text = (e.clipboardData || window.clipboardData).getData('text');
        const start = messageInput.selectionStart;
        const end = messageInput.selectionEnd;
        messageInput.value = messageInput.value.substring(0, start) + text + messageInput.value.substring(end);
        messageInput.dispatchEvent(new Event('input'));
    });

    document.querySelectorAll('.input-icons button').forEach((btn) => {
        btn.addEventListener('click', () => {
            if (btn.classList.contains('files-btn')) {
                fileModalOverlay.classList.add('active');
            }
            if (btn.classList.contains('think-btn')) {
                thinkActive = !thinkActive;
                btn.classList.toggle('active', thinkActive);
                // Если активируем режим think, отключаем режим DeepSearch и режим генерации изображений
                if (thinkActive) {
                    if (deepSearchActive) {
                        deepSearchActive = false;
                        deepsearchBtn.classList.remove('active');
                    }
                    if (imageGenActive) {
                        imageGenActive = false;
                        imageGenBtn.classList.remove('active');
                    }
                }
                updateSendButton();
            }

        });
    });

    function showFileError(file) {
        const extension = file.name.split('.').pop();
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-notification';
        errorDiv.textContent = `Error: file with extension "${extension}" is not supported.`;
        document.body.appendChild(errorDiv);

        setTimeout(() => {
            errorDiv.classList.add('show');
        }, 10);

        setTimeout(() => {
            errorDiv.classList.remove('show');
            setTimeout(() => {
                errorDiv.remove();
            }, 500);
        }, 3000);
    }

    fileInput.addEventListener('change', () => {
        if (fileInput.files.length > 0) {
            Array.from(fileInput.files).forEach(file => {
                if (!attachedFiles.some(f => f.name === file.name) && validateFileExtension(file)) {
                    if (!validateFileUpload(file)) {
                        return;
                    }
                    attachedFiles.push(file);
                    showAttachment(file);
                } else if (!validateFileExtension(file)) {
                    showFileError(file);
                }
            });
        }
        updateSendButton();
    });

    document.addEventListener('dragenter', (e) => {
        e.preventDefault();
        dragCounter++;
        if (!isDragging) {
            isDragging = true;
            dragOverlay.classList.add('active');
        }
    });

    document.addEventListener('dragleave', (e) => {
        e.preventDefault();
        dragCounter--;
        if (dragCounter === 0) {
            isDragging = false;
            dragOverlay.classList.remove('active');
        }
    });

    document.addEventListener('dragover', (e) => {
        e.preventDefault();
    });

    document.addEventListener('drop', (e) => {
        e.preventDefault();
        dragCounter = 0;
        isDragging = false;
        dragOverlay.classList.remove('active');
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            Array.from(files).forEach(file => {
                if (!attachedFiles.some(f => f.name === file.name) && validateFileExtension(file)) {
                    if (!validateFileUpload(file)) {
                        return;
                    }
                    attachedFiles.push(file);
                    showAttachment(file);
                } else if (!validateFileExtension(file)) {
                    showFileError(file);
                }
            });
        }
        updateSendButton();
    });

    document.addEventListener('paste', async (e) => {
        e.preventDefault();

        if (isStreaming || isTyping) return;

        const items = Array.from(e.clipboardData.items);
        const imageItems = items.filter(item => item.type.startsWith('image/'));

        const currentImages = attachedFiles.filter(f => f.type.startsWith('image/')).length;
        const remainingSlots = 3 - currentImages;

        if (remainingSlots <= 0) {
            showError('Можно добавить не более 3 изображений.');
            return;
        }

        if (attachedFiles.some(f => !f.type.startsWith('image/'))) {
            showError('После добавления файла нельзя добавлять изображения.');
            return;
        }

        const imagesToProcess = imageItems.slice(0, remainingSlots);

        for (const item of imagesToProcess) {
            const file = item.getAsFile();
            if (file) {
                const newFile = new File([file], `clipboard_image_${Date.now()}.png`, {
                    type: file.type
                });

                if (!validateFileUpload(newFile)) continue;

                attachedFiles.push(newFile);
                await showAttachment(newFile);
            }
        }

        if (imageItems.length > remainingSlots) {
            showError(`Добавлено только ${remainingSlots} из ${imageItems.length} изображений из буфера обмена из-за ограничения.`);
        }
    });

    closePreviewBtn.addEventListener('click', () => {
        imagePreviewOverlay.classList.remove('active');
    });

    settingsBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        alert('Настройки пользователя');
    });

    userInfo.addEventListener('click', () => {
        alert('Переход на страницу пользователя (будет добавлено в будущем)');
    });

    newChatBtn.addEventListener('click', () => {
        createNewChat();
    });

    openSidebarBtn.addEventListener('click', () => {
        isSidebarOpen = !isSidebarOpen;
        sidebar.classList.toggle('open', isSidebarOpen);
    });

    closeSidebarBtn.addEventListener('click', () => {
        isSidebarOpen = false;
        sidebar.classList.remove('open');
    });



    // Обработчик для кнопки закрытия окна предпросмотра
    filePreviewCloseBtn.addEventListener('click', closeFilePreview);

    // Приветствие с учетом часового пояса (+05)
    const now = new Date();
    const hours = (now.getUTCHours() + 5) % 24; // Учитываем часовой пояс +05
    let timeOfDay = hours < 12 ? 'morning' : hours < 18 ? 'afternoon' : 'evening';
    greetingText.innerHTML = `<span class="greeting-time">Good ${timeOfDay}</span>, <span class="greeting-user">User</span>!`;
    setTimeout(() => greeting.classList.add('visible'), 300);

    chatInputWrapper.addEventListener('click', () => messageInput.focus());

    dropdownButton.addEventListener('click', () => {
        isDropdownOpen = !isDropdownOpen;
        dropdownMenu.classList.toggle('active', isDropdownOpen);
        dropdownButton.classList.toggle('active', isDropdownOpen);

        if (isDropdownOpen) {
            const dropdownRect = dropdownButton.getBoundingClientRect();
            const windowHeight = window.innerHeight;
            const menuHeight = dropdownMenu.scrollHeight || 150; // Предполагаемая высота меню, если еще не отображено

            // Если расстояние от кнопки до низа окна меньше высоты меню, открываем вверх
            if (windowHeight - dropdownRect.bottom < menuHeight) {
                dropdownMenu.style.bottom = `${dropdownRect.height + 5}px`; // Отступ от кнопки
                dropdownMenu.style.top = 'auto';
            } else {
                dropdownMenu.style.top = `${dropdownRect.bottom + 5}px`; // Открытие вниз как запасной вариант
                dropdownMenu.style.bottom = 'auto';
            }
        }
    });

    document.addEventListener('click', (e) => {
        if (!dropdownButton.contains(e.target) && !dropdownMenu.contains(e.target)) {
            isDropdownOpen = false;
            dropdownMenu.classList.remove('active');
            dropdownButton.classList.remove('active');
        }
    });

    messageInput.addEventListener('input', () => {
        messageInput.style.height = 'auto';
        messageInput.style.height = messageInput.scrollHeight + 'px';
        updateSendButton();
        toggleScrollDownButton();
    });

    const buttonsToAnimate = document.querySelectorAll('.action-btn, .input-icons button, .dropdown-button, .send-button');
    buttonsToAnimate.forEach((btn, index) => {
        setTimeout(() => {
            btn.classList.add('visible');
        }, index * 100);
    });

    const filesBtn = document.querySelector('.files-btn');
    filesBtn.addEventListener('click', () => {
        fileModalOverlay.classList.add('active');
    });

    closeFileModalBtn.addEventListener('click', () => {
        fileModalOverlay.classList.remove('active');
        cameraFeedContainer.classList.remove('active');
        if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
            cameraStream = null;
        }
    });

    uploadFromDeviceBtn.addEventListener('click', () => {
        fileInput.click();
        fileModalOverlay.classList.remove('active');
    });

    captureFromCameraBtn.addEventListener('click', async () => {
        try {
            cameraFeedContainer.classList.add('active');
            cameraStream = await navigator.mediaDevices.getUserMedia({ video: true });
            cameraFeed.srcObject = cameraStream;
        } catch (error) {
            showError('Camera access error: ' + error.message);
            cameraFeedContainer.classList.remove('active');
        }
    });

    captureBtn.addEventListener('click', () => {
        const context = cameraCanvas.getContext('2d');
        cameraCanvas.width = cameraFeed.videoWidth;
        cameraCanvas.height = cameraFeed.videoHeight;
        context.drawImage(cameraFeed, 0, 0, cameraCanvas.width, cameraCanvas.height);
        cameraCanvas.toBlob(blob => {
            const file = new File([blob], `photo_${Date.now()}.jpg`, { type: 'image/jpeg' });
            if (validateFileUpload(file)) {
                attachedFiles.push(file);
                showAttachment(file);
            }
        }, 'image/jpeg');
        cameraFeedContainer.classList.remove('active');
        if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
            cameraStream = null;
        }
        fileModalOverlay.classList.remove('active');
    });

    // Обработчик для кнопки DeepSearch
    const deepsearchBtn = document.querySelector('.deepsearch-btn');
    deepsearchBtn.addEventListener('click', () => {
        // Если режим DeepSearch уже активен, отключаем его
        if (deepSearchActive) {
            deepSearchActive = false;
            deepsearchBtn.classList.remove('active');
            return;
        }
        
        // Если активен режим think, отключаем его
        if (thinkActive) {
            thinkActive = false;
            thinkBtn.classList.remove('active');
        }
        
        // Если активен режим генерации изображений, отключаем его
        if (imageGenActive) {
            imageGenActive = false;
            imageGenBtn.classList.remove('active');
        }
        
        // Активируем режим DeepSearch
        deepSearchActive = true;
        // Активируем кнопку для визуальной индикации
        deepsearchBtn.classList.add('active');
    });
    
    // Обработчик для кнопки генерации изображений
    const imageGenBtn = document.querySelector('.image-gen-btn');
    imageGenBtn.addEventListener('click', () => {
        // Если режим генерации изображений уже активен, отключаем его
        if (imageGenActive) {
            imageGenActive = false;
            imageGenBtn.classList.remove('active');
            
            // Возвращаем модели для текстового чата в dropdown
            dropdownMenu.innerHTML = '';
            models.forEach(model => {
                const item = document.createElement('div');
                item.className = 'dropdown-item';
                item.setAttribute('data-value', model.id);
                item.textContent = model.name;
                dropdownMenu.appendChild(item);

                item.addEventListener('click', () => {
                    selectedModel.textContent = model.name;
                    selectedModel.dataset.model = model.id;
                    isDropdownOpen = false;
                    dropdownMenu.classList.remove('active');
                    dropdownButton.classList.remove('active');
                });
            });
            
            // Возвращаем выбранную модель для текстового чата
            selectedModel.textContent = 'Veronica';
            selectedModel.dataset.model = 'veronica';
            return;
        }
        
        // Если активен режим think, отключаем его
        if (thinkActive) {
            thinkActive = false;
            thinkBtn.classList.remove('active');
        }
        
        // Если активен режим DeepSearch, отключаем его
        if (deepSearchActive) {
            deepSearchActive = false;
            deepsearchBtn.classList.remove('active');
        }
        
        // Активируем режим генерации изображений
        imageGenActive = true;
        // Активируем кнопку для визуальной индикации
        imageGenBtn.classList.add('active');
        
        // Обновляем dropdown-menu для отображения моделей генерации изображений
        dropdownMenu.innerHTML = '';
        imageGenModels.forEach(model => {
            const item = document.createElement('div');
            item.className = 'dropdown-item';
            item.setAttribute('data-value', model.id);
            item.textContent = model.name;
            dropdownMenu.appendChild(item);

            item.addEventListener('click', () => {
                selectedModel.textContent = model.name;
                selectedModel.dataset.model = model.id;
                isDropdownOpen = false;
                dropdownMenu.classList.remove('active');
                dropdownButton.classList.remove('active');
            });
        });
        
        // Устанавливаем Gemini 2.0 как выбранную модель для генерации изображений
        if (imageGenModels.length > 0) {
            selectedModel.textContent = imageGenModels[0].name;
            selectedModel.dataset.model = imageGenModels[0].id;
        }
    });
    
    // Функция для показа уведомления
    function showNotification(message) {
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = message;
        document.body.appendChild(notification);
        
        // Добавляем класс show для анимации появления
        setTimeout(() => {
            notification.classList.add('show');
        }, 10);
        
        // Через 3 секунды скрываем уведомление
        setTimeout(() => {
            notification.classList.remove('show');
            // Удаляем элемент после завершения анимации
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 500);
        }, 3000);
    }

    // Функция для отправки запроса DeepSearch
    async function sendDeepSearchQuery(query) {
        let timerInterval;
        let elapsedSeconds = 0;
        
        // Скрываем приветствие при любом первом запросе
        if (greeting.classList.contains('visible')) {
            greeting.classList.add('hidden');
            greeting.classList.remove('visible');
            chatInputContainer.classList.add('moved');
        }
        
        // Создаем чат, если это первый запрос
        if (isFirstMessage || !currentChatId) {
            try {
                currentChatId = await createChatWithRetry();
                isFirstMessage = false;
                // Обновляем список чатов после создания нового чата
                await loadChatHistory();
            } catch (error) {
                console.error('Error creating chat after retries:', error);
                appendMessage('assistant', `Error creating chat: ${error.message}. Please try again later.`, true, [], true);
                return;
            }
        }
        
        // Сначала добавляем сообщение пользователя
        appendMessage('user', query, true, []);
        
        // Затем добавляем индикатор DeepSearch после сообщения пользователя
        const indicator = deepSearchIndicator;
        chatMessages.appendChild(indicator);
        indicator.classList.add('active');
        
        // Запускаем таймер для отслеживания времени обработки
        elapsedSeconds = 1;
        timerInterval = setInterval(() => {
            elapsedSeconds++;
            indicator.querySelector('.deepsearch-text').textContent = `Searching... ${elapsedSeconds}s`;
        }, 1000);

        scrollToBottomIfNeeded();

        isStreaming = true;
        stopStream = false;
        abortController = new AbortController();
        updateSendButton();

        try {

            // Используем текущую выбранную модель для DeepSearch
            const model = selectedModel.dataset.model;
            const response = await fetch('/veronica/deepsearch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    query: query,
                    chat_id: currentChatId,
                    model: model
                }),
                signal: abortController.signal
            });

            if (!response.ok) {
                throw new Error(`Network response was not ok: ${response.status}`);
            }

            const data = await response.json();
            if (!data.response) {
                throw new Error('No response content received from server');
            }

            let finalMessage = data.response;
            // Добавляем информацию о времени обработки
            finalMessage += `\n\n(Processed in ${elapsedSeconds} seconds)`;

            if (!stopStream) {
                appendMessage('assistant', finalMessage, false);
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                // Сообщение уже добавлено в обработчике sendButton
            } else {
                console.error('Error sending DeepSearch query:', error);
                appendMessage('assistant', `Error executing DeepSearch: ${error.message}`, true, [], true);
            }
        } finally {
            clearInterval(timerInterval);
            if (chatMessages.contains(indicator)) {
                indicator.classList.remove('active');
                chatMessages.removeChild(indicator);
            }
            abortController = null;
            isStreaming = false;
            // DeepSearch не использует режим think
            if (!isTyping) {
                updateSendButton();
            }
            disableAutoScroll = false;
        }
    }
    
    // Функция для отправки запроса на генерацию изображений
    async function sendImageGenerationQuery(prompt) {
        let timerInterval;
        let elapsedSeconds = 0;
        
        // Скрываем приветствие при любом первом запросе
        if (greeting.classList.contains('visible')) {
            greeting.classList.add('hidden');
            greeting.classList.remove('visible');
            chatInputContainer.classList.add('moved');
        }
        
        // Создаем чат, если это первый запрос
        if (isFirstMessage || !currentChatId) {
            try {
                currentChatId = await createChatWithRetry();
                isFirstMessage = false;
                // Обновляем список чатов после создания нового чата
                await loadChatHistory();
            } catch (error) {
                console.error('Error creating chat after retries:', error);
                appendMessage('assistant', `Error creating chat: ${error.message}. Please try again later.`, true, [], true);
                return;
            }
        }
        
        // Сначала добавляем сообщение пользователя
        appendMessage('user', prompt, true, []);
        
        // Затем добавляем индикатор генерации изображений после сообщения пользователя
        const indicator = imageGenIndicator;
        chatMessages.appendChild(indicator);
        indicator.classList.add('active');
        
        // Запускаем таймер для отслеживания времени обработки
        elapsedSeconds = 1;
        timerInterval = setInterval(() => {
            elapsedSeconds++;
            indicator.querySelector('.image-gen-text').textContent = `Generating image... ${elapsedSeconds}s`;
        }, 1000);

        scrollToBottomIfNeeded();

        isStreaming = true;
        stopStream = false;
        abortController = new AbortController();
        updateSendButton();

        try {
            // Используем наш бэкенд-эндпоинт для генерации изображений через Hugging Face API
            const response = await fetch('/veronica/generate-image', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    prompt: prompt,
                    chat_id: currentChatId,
                    model: selectedModel.dataset.model // Используем выбранную модель
                }),
                signal: abortController.signal
            });

            if (!response.ok) {
                throw new Error(`Network response was not ok: ${response.status}`);
            }

            // Получаем ответ от сервера
            const responseData = await response.json();
            
            if (!responseData.response) {
                throw new Error('Не удалось получить ответ от сервера');
            }
            
            // Извлекаем URL изображения из ответа
            // Проверяем разные форматы ответа: markdown формат и формат image-card
            let imageUrl;
            const markdownMatch = responseData.response.match(/!\[Generated Image\]\(([^)]+)\)/);
            const imageCardMatch = responseData.response.match(/<image-card[^>]*src="([^"]+)"[^>]*>/);
            
            if (markdownMatch && markdownMatch[1]) {
                imageUrl = markdownMatch[1];
            } else if (imageCardMatch && imageCardMatch[1]) {
                imageUrl = imageCardMatch[1];
            } else {
                console.error('Response format:', responseData.response);
                throw new Error('Не удалось получить URL изображения из ответа сервера');
            }
            
            
            // Создаем объект с информацией об изображении
            const imageAttachment = [
                {
                    name: `generated-image-${Date.now()}.png`,
                    url: imageUrl,
                    type: 'image'
                }
            ];

            // Добавляем сообщение с изображением
            if (!stopStream) {
                appendMessage('assistant', '', false, imageAttachment);
                // Добавляем текст о времени генерации под изображением
                setTimeout(() => {
                    const lastMessage = document.querySelector('.chat-messages .message:last-child');
                    if (lastMessage) {
                        const timeInfo = document.createElement('div');
                        timeInfo.className = 'generation-time';
                        timeInfo.textContent = `Generated in ${elapsedSeconds} seconds`;
                        lastMessage.appendChild(timeInfo);
                    }
                }, 100);
            }
        } catch (error) {
            if (error.name === 'AbortError') {
                // Сообщение уже добавлено в обработчике sendButton
            } else {
                console.error('Error generating image:', error);
                appendMessage('assistant', `Error generating image: ${error.message}`, true, [], true);
            }
        } finally {
            clearInterval(timerInterval);
            if (chatMessages.contains(indicator)) {
                indicator.classList.remove('active');
                chatMessages.removeChild(indicator);
            }
            abortController = null;
            isStreaming = false;
            // Не сбрасываем флаг imageGenActive, чтобы режим оставался активным
            // до тех пор, пока пользователь сам его не отключит
            if (!isTyping) {
                updateSendButton();
            }
            disableAutoScroll = false;
        }
    }

    // Инициализация
    loadChatHistory();
    await loadModels();
});
 </script>
    <!-- Скрипт для анимации звездного неба -->
    <script>
        (() => {
  // Создаем canvas для звездного неба
  const createStarrySky = () => {
    // Проверяем, существует ли уже canvas
    let canvas = document.getElementById('starry-sky');
    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.id = 'starry-sky';
      // Добавляем canvas в начало body, чтобы он был под всеми элементами
      document.body.appendChild(canvas);
      // Устанавливаем z-index, чтобы canvas был под всеми элементами
      canvas.style.zIndex = '-1000';
    }
    return canvas;
  };

  // Инициализация canvas и контекста
  const canvas = createStarrySky();
  const ctx = canvas.getContext('2d');
  const dpr = Math.min(2, window.devicePixelRatio || 1.5);
  let w = 0, h = 0;
  let isActive = false;
  let inactivityTimer = null;
  let animationFrame = null;

  // Функция изменения размера canvas
  function resize() {
    w = window.innerWidth;
    h = window.innerHeight;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
  }

  // Настройка звезд
  const stars = [];
  const STAR_COUNT = 120;
  
  function initStars() {
    stars.length = 0; // Очищаем массив звезд
    for (let i = 0; i < STAR_COUNT; i++) {
      stars.push({
        x: Math.random() * w * dpr,
        y: Math.random() * h * dpr,
        r: Math.random() * 0.8 * dpr + 0.2,
        tw: Math.random() * 1000,
        speed: 0,
        fall: false,
        life: 1
      });
    }
  }

  // Создание падающей звезды
  function spawnFallingStar() {
    const s = stars[Math.floor(Math.random() * stars.length)];
    if (!s.fall) {
      s.fall = true;
      s.speed = 3 + Math.random() * 3;
      s.life = 1;
    }
  }

  // Переменные для анимации
  let lastFall = 0;
  let start = performance.now();
  let skyRotation = 0;

  // Функция отрисовки
  function draw(now) {
    if (!isActive) return;

    const dt = (now - start) / 1000;
    const fade = Math.min(1, dt / 2);

    ctx.fillStyle = `rgba(5,6,10,${0.5 * fade})`;
    ctx.fillRect(0, 0, w * dpr, h * dpr);

    ctx.save();
    ctx.translate(w * dpr / 2, h * dpr / 2);
    ctx.rotate(skyRotation);
    ctx.translate(-w * dpr / 2, -h * dpr / 2);

    stars.forEach(s => {
      if (s.fall) {
        s.x += s.speed * 2 * dpr;
        s.y += s.speed * dpr;
        s.life -= 0.01;
        ctx.strokeStyle = `rgba(255,255,200,${s.life})`;
        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(s.x - 25 * dpr, s.y - 12 * dpr);
        ctx.stroke();
        if (s.life <= 0 || s.x > w * dpr || s.y > h * dpr) {
          s.x = Math.random() * w * dpr;
          s.y = Math.random() * h * dpr * 0.5;
          s.fall = false;
          s.life = 1;
        }
      } else {
        const tw = 0.5 + 0.5 * Math.sin((now * 0.002) + s.tw);
        ctx.globalAlpha = fade * (0.5 + 0.5 * tw);
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fill();
      }
    });

    ctx.restore();
    ctx.globalAlpha = 1;

    if (now - lastFall > 3000 + Math.random() * 4000) {
      spawnFallingStar();
      lastFall = now;
    }

    skyRotation += 0.00002; // Медленное вращение неба
    animationFrame = requestAnimationFrame(draw);
  }

  // Показать звездное небо
  function showStarrySky() {
    if (!isActive) {
      isActive = true;
      canvas.style.opacity = '1'; // Уменьшаем непрозрачность еще больше
      // Делаем текстовое поле прозрачным при активации заставки
      const chatInputWrapper = document.querySelector('.chat-input-wrapper');
      if (chatInputWrapper) {
        chatInputWrapper.style.transition = 'background-color 1.5s ease';
        chatInputWrapper.style.backgroundColor = 'rgba(38, 38, 36, 0.3)';
      }
      // Делаем dropdown-button прозрачным при активации заставки
      const dropdownButton = document.querySelector('.dropdown-button');
      if (dropdownButton) {
        dropdownButton.style.transition = 'background-color 1.5s ease';
        dropdownButton.style.backgroundColor = 'rgba(38, 38, 36, 0.3)';
      }
      // Не добавляем класс к body, чтобы не влиять на основной интерфейс
      // document.body.classList.add('starry-sky-active');
      start = performance.now();
      resize();
      initStars();
      if (animationFrame) cancelAnimationFrame(animationFrame);
      animationFrame = requestAnimationFrame(draw);
    }
  }

  // Скрыть звездное небо
  function hideStarrySky() {
    if (isActive) {
      isActive = false;
      canvas.style.opacity = '0';
      // Возвращаем непрозрачность текстового поля
      const chatInputWrapper = document.querySelector('.chat-input-wrapper');
      if (chatInputWrapper) {
        chatInputWrapper.style.transition = 'background-color 1.5s ease';
        chatInputWrapper.style.backgroundColor = '#262624';
      }
      // Возвращаем непрозрачность dropdown-button
      const dropdownButton = document.querySelector('.dropdown-button');
      if (dropdownButton) {
        dropdownButton.style.transition = 'background-color 1.5s ease';
        dropdownButton.style.backgroundColor = '#262624';
      }
      // Не удаляем класс, так как мы его не добавляем
      // document.body.classList.remove('starry-sky-active');
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = null;
      }
    }
  }

  // Сброс таймера неактивности
  function resetInactivityTimer() {
    if (inactivityTimer) {
      clearTimeout(inactivityTimer);
    }
    
    // Если звездное небо активно, скрываем его
    if (isActive) {
      hideStarrySky();
    }
    
    // Устанавливаем новый таймер
    inactivityTimer = setTimeout(() => {
      showStarrySky();
    }, 10000); // 10 секунд неактивности
  }

  // Инициализация
  function init() {
    window.addEventListener('resize', resize);
    resize();
    initStars();

    // События для отслеживания активности пользователя
    const userEvents = [
      'mousemove', 'mousedown', 'mouseup', 'click', 
      'keypress', 'keydown', 'keyup',
      'scroll', 'wheel',
      'touchstart', 'touchmove', 'touchend',
      'focus', 'blur', 'input', 'change'
    ];
    
    userEvents.forEach(event => {
      document.addEventListener(event, resetInactivityTimer, { passive: true });
    });

    // Специальная обработка для элементов интерфейса
    const chatInput = document.querySelector('.chat-input');
    if (chatInput) {
      chatInput.addEventListener('focus', resetInactivityTimer, { passive: true });
    }

    // Запускаем таймер неактивности
    resetInactivityTimer();
  }

  // Запуск инициализации
  init();
})();
    </script>
    </body>
    </html>
